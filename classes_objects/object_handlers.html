

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Object handlers &mdash; PHP Internals Book</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="PHP Internals Book" href="../index.html" />
    <link rel="up" title="Classes and objects" href="../classes_objects.html" />
    <link rel="next" title="Iterators" href="iterators.html" />
    <link rel="prev" title="Implementing typed arrays" href="implementing_typed_arrays.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Object handlers</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="implementing_typed_arrays.html">Implementing typed arrays</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="iterators.html">Iterators</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="object-handlers">
<h1>Object handlers<a class="headerlink" href="#object-handlers" title="Permalink to this headline">¶</a></h1>
<p>In the previous sections you already had some contact with object handlers. In particular you should know how to create
the structure used to specify the handlers and how to implement cloning behavior using <tt class="docutils literal"><span class="pre">clone_obj</span></tt>. But this is just
the beginning: Nearly all operations on objects in PHP go through object handlers and every magic method or magic
interface is implemented with an object or class handler internally. Furthermore there are quite a few handlers which
are not exposed to userland PHP. For example internal classes can have custom comparison and cast behavior.</p>
<p>As the number of different object handlers is rather large we can only discuss examples (using the typed array
implementation from the last section) for a few of them. For all the others only a short description is provided.</p>
<div class="section" id="an-overview">
<h2>An Overview<a class="headerlink" href="#an-overview" title="Permalink to this headline">¶</a></h2>
<p>As of this writing there are 26 object handlers, which are listed in the following with their signature and a small
description.</p>
<dl class="member">
<dt id="read_property">
zval *<tt class="descname">read_property</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*member</em>, int<em>&nbsp;type</em>, const struct _zend_literal *key<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#read_property" title="Permalink to this definition">¶</a></dt>
<dt id="write_property">
void <tt class="descname">write_property</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*member</em>, zval<em>&nbsp;*value</em>, const struct _zend_literal *key<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#write_property" title="Permalink to this definition">¶</a></dt>
<dt id="has_property">
int <tt class="descname">has_property</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*member</em>, int<em>&nbsp;has_set_exists</em>, const struct _zend_literal *key<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#has_property" title="Permalink to this definition">¶</a></dt>
<dt id="unset_property">
void <tt class="descname">unset_property</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*member</em>, const struct _zend_literal *key<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#unset_property" title="Permalink to this definition">¶</a></dt>
<dt id="get_property_ptr_ptr">
zval **<tt class="descname">get_property_ptr_ptr</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*member</em>, const struct _zend_literal *key<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_property_ptr_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>These handlers correspond to the <tt class="docutils literal"><span class="pre">__get</span></tt>, <tt class="docutils literal"><span class="pre">__set</span></tt>, <tt class="docutils literal"><span class="pre">__isset</span></tt> and <tt class="docutils literal"><span class="pre">__unset</span></tt> methods. <tt class="docutils literal"><span class="pre">get_property_ptr_ptr</span></tt>
is the internal equivalent of <tt class="docutils literal"><span class="pre">__get</span></tt> returning by reference. The <tt class="docutils literal"><span class="pre">zend_literal</span> <span class="pre">*key</span></tt> passed to these functions
exists as an optimization, for example it contains a precomputed hash of of the property name.</p>
</dd></dl>

<dl class="member">
<dt id="read_dimension">
zval *<tt class="descname">read_dimension</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*offset</em>, int type<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#read_dimension" title="Permalink to this definition">¶</a></dt>
<dt id="write_dimension">
void <tt class="descname">write_dimension</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*offset</em>, zval *value<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#write_dimension" title="Permalink to this definition">¶</a></dt>
<dt id="has_dimension">
int <tt class="descname">has_dimension</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;*member</em>, int check_empty<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#has_dimension" title="Permalink to this definition">¶</a></dt>
<dt id="unset_dimension">
void <tt class="descname">unset_dimension</tt><big>(</big>zval<em>&nbsp;*object</em>, zval *offset<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#unset_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>This set of handlers is the internal representation of the <tt class="docutils literal"><span class="pre">ArrayAccess</span></tt> interface.</p>
</dd></dl>

<dl class="member">
<dt id="set">
void <tt class="descname">set</tt><big>(</big>zval<em>&nbsp;**object</em>, zval *value<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#set" title="Permalink to this definition">¶</a></dt>
<dt id="get">
zval *<tt class="descname">get</tt><big>(</big>zval *object<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get" title="Permalink to this definition">¶</a></dt>
<dd><p>These handlers get/set the &#8220;object value&#8221;. They can be used to override (to a certain degree) the compound
assignment operators (like <tt class="docutils literal"><span class="pre">+=</span></tt> or <tt class="docutils literal"><span class="pre">++</span></tt>) and exist mainly for the purpose of proxy objects. In practice they are
rarely used.</p>
</dd></dl>

<dl class="member">
<dt id="get_properties">
HashTable *<tt class="descname">get_properties</tt><big>(</big>zval *object<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_properties" title="Permalink to this definition">¶</a></dt>
<dt id="get_debug_info">
HashTable *<tt class="descname">get_debug_info</tt><big>(</big>zval<em>&nbsp;*object</em>, int *is_temp<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_debug_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to get the object properties as a hashtable. The former is more general purpose, for example it is also used
for the <tt class="docutils literal"><span class="pre">get_object_vars</span></tt> function. The latter on the other hand is used exclusively to display properties in
debugging functions like <tt class="docutils literal"><span class="pre">var_dump</span></tt>. So even if your object does not provide any formal properties you can still
have a meaningful debug output.</p>
</dd></dl>

<dl class="member">
<dt id="get_method">
union _zend_function *<tt class="descname">get_method</tt><big>(</big>zval<em>&nbsp;**object_ptr</em>, char<em>&nbsp;*method</em>, int<em>&nbsp;method_len</em>, const struct _zend_literal *key<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_method" title="Permalink to this definition">¶</a></dt>
<dt id="call_method">
int <tt class="descname">call_method</tt><big>(</big>const char<em>&nbsp;*method</em>, INTERNAL_FUNCTION_PARAMETERS<big>)</big><a class="headerlink" href="#call_method" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="docutils literal"><span class="pre">get_method</span></tt> handler fetches the <tt class="docutils literal"><span class="pre">zend_function</span></tt> used to call a certain method. If there is no particular
<tt class="docutils literal"><span class="pre">zend_function</span></tt> that you want to invoke, but you rather want a <tt class="docutils literal"><span class="pre">__call</span></tt>-like catch-all behavior, then
<tt class="docutils literal"><span class="pre">get_method</span></tt> can signal that it is a <tt class="docutils literal"><span class="pre">ZEND_OVERLOADED_FUNCTION</span></tt> in which case the <tt class="docutils literal"><span class="pre">call_method</span></tt> handler will
be used instead.</p>
</dd></dl>

<dl class="member">
<dt id="get_constructor">
union _zend_function *<tt class="descname">get_constructor</tt><big>(</big>zval *object<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <tt class="docutils literal"><span class="pre">get_method</span></tt>, but getting the constructor function. The most common reason to override this handler is to
disallow manual construction by throwing an error in the handler.</p>
</dd></dl>

<dl class="member">
<dt id="count_elements">
int <tt class="descname">count_elements</tt><big>(</big>zval<em>&nbsp;*object</em>, long *count<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#count_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This is just the internal way of implementing the <tt class="docutils literal"><span class="pre">Countable::count</span></tt> method.</p>
</dd></dl>

<dl class="member">
<dt id="compare_objects">
int <tt class="descname">compare_objects</tt><big>(</big>zval<em>&nbsp;*object1</em>, zval *object2<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#compare_objects" title="Permalink to this definition">¶</a></dt>
<dt id="cast_object">
int <tt class="descname">cast_object</tt><big>(</big>zval<em>&nbsp;*readobj</em>, zval<em>&nbsp;*retval</em>, int type<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#cast_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal classes have the ability to implement a custom compare behavior and override casting behavior for all
types. Userland classes on the other hand only have the ability to override object to string casting through
<tt class="docutils literal"><span class="pre">__toString</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="get_closure">
int <tt class="descname">get_closure</tt><big>(</big>zval<em>&nbsp;*obj</em>, zend_class_entry<em>&nbsp;**ce_ptr</em>, union _zend_function<em>&nbsp;**fptr_ptr</em>, zval **zobj_ptr<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_closure" title="Permalink to this definition">¶</a></dt>
<dd><p>This handler is invoked when the the object is used as a function, i.e. it is the internal version of <tt class="docutils literal"><span class="pre">__invoke</span></tt>.
The name derives from the fact that its main use is for the implementation of closures (the <tt class="docutils literal"><span class="pre">Closure</span></tt> class).</p>
</dd></dl>

<dl class="member">
<dt id="get_class_entry">
zend_class_entry *<tt class="descname">get_class_entry</tt><big>(</big>const zval *object<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_class_entry" title="Permalink to this definition">¶</a></dt>
<dt id="get_class_name">
int <tt class="descname">get_class_name</tt><big>(</big>const zval<em>&nbsp;*object</em>, const char<em>&nbsp;**class_name</em>, zend_uint<em>&nbsp;*class_name_len</em>, int parent<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_class_name" title="Permalink to this definition">¶</a></dt>
<dd><p>These two handlers are used to get the class entry and class name from an object. There should be little reason to
overwrite them. The only occasion that I can think of where this would be necessary is if you choose to create a
custom object structure that does <em>not</em> contain the standard <tt class="docutils literal"><span class="pre">zend_object</span></tt> as a substructure. (This is entirely
possible, but not usually done.)</p>
</dd></dl>

<dl class="member">
<dt id="add_ref">
void <tt class="descname">add_ref</tt><big>(</big>zval *object<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#add_ref" title="Permalink to this definition">¶</a></dt>
<dt id="del_ref">
void <tt class="descname">del_ref</tt><big>(</big>zval *object<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#del_ref" title="Permalink to this definition">¶</a></dt>
<dt id="clone_obj">
zend_object_value <tt class="descname">clone_obj</tt><big>(</big>zval *object<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#clone_obj" title="Permalink to this definition">¶</a></dt>
<dt id="get_gc">
HashTable *<tt class="descname">get_gc</tt><big>(</big>zval<em>&nbsp;*object</em>, zval<em>&nbsp;***table</em>, int *n<em>&nbsp;TSRMLS_DC</em><big>)</big><a class="headerlink" href="#get_gc" title="Permalink to this definition">¶</a></dt>
<dd><p>This set of handlers is used for various object maintenance tasks. <tt class="docutils literal"><span class="pre">add_ref</span></tt> is called when a new zval starts
referencing the object, <tt class="docutils literal"><span class="pre">del_ref</span></tt> is called when a reference is removed. By default these handlers will change
the refcount in the object store. Once again there should be virtually no reason to overwrite them. The only
application I can think of is when you choose <em>not</em> to use the Zend object store, but rather use some custom
storage facility.</p>
<p>You already know the <tt class="docutils literal"><span class="pre">clone_obj</span></tt> handler, so I&#8217;ll jump right to <tt class="docutils literal"><span class="pre">get_gc</span></tt>: This handler should return all
variables that are held by the object, so cyclic dependencies can be properly collected.</p>
</dd></dl>

</div>
<div class="section" id="implementing-array-access-using-object-handlers">
<h2>Implementing array access using object handlers<a class="headerlink" href="#implementing-array-access-using-object-handlers" title="Permalink to this headline">¶</a></h2>
<p>In the previous section the <tt class="docutils literal"><span class="pre">ArrayAccess</span></tt> interface was used to provide array-like behavior for the buffer views. Now
we want to improve the implementation by using the respective <tt class="docutils literal"><span class="pre">*_dimension</span></tt> object handlers. These same handlers are
also used to implement <tt class="docutils literal"><span class="pre">ArrayAccess</span></tt>, but providing a custom implementation will be faster as the overhead of calling
methods is avoided.</p>
<p>The object handlers for dimensions are <tt class="docutils literal"><span class="pre">read_dimension</span></tt>, <tt class="docutils literal"><span class="pre">write_dimension</span></tt>, <tt class="docutils literal"><span class="pre">has_dimension</span></tt> and
<tt class="docutils literal"><span class="pre">unset_dimension</span></tt>. They all take the object zval as first argument and the offset zval as second. For our purposes
the offset has to be an integer, so let&#8217;s first introduce a helper function for getting the long value from a zval (in
order to avoid all the repeating cast code):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">long</span> <span class="nf">get_long_from_zval</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">zv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">zv</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="n">lval</span><span class="p">;</span>
        <span class="n">Z_ADDREF_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
        <span class="n">convert_to_long_ex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="p">);</span>
        <span class="n">lval</span> <span class="o">=</span> <span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
        <span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">lval</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now writing the respective handlers is rather straightforward. For example, this is how the <tt class="docutils literal"><span class="pre">read_dimension</span></tt> handler
looks like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">zval</span> <span class="o">*</span><span class="nf">array_buffer_view_read_dimension</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">zv_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span> <span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_view_object</span> <span class="o">*</span><span class="n">intern</span> <span class="o">=</span> <span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">object</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
    <span class="n">zval</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zv_offset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Cannot append to a typed array&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">get_long_from_zval</span><span class="p">(</span><span class="n">zv_offset</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Offset is outside the buffer range&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">buffer_view_offset_get</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="n">Z_DELREF_P</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span> <span class="cm">/* Refcount should be 0 if not referenced from ext / engine */</span>
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Something that is slightly odd about this handler is the <tt class="docutils literal"><span class="pre">Z_DELREF_P(retval)</span></tt> at the end: <tt class="docutils literal"><span class="pre">read_dimension</span></tt> is
expected to return a zval with refcount 0 if the returned zval isn&#8217;t used anywhere else (as it is the case for us). The
engine will increment the refcount itself. The refcount 0 also tells the engine that reference operations on the return
value don&#8217;t make sense (as nothing would be actually modified).</p>
<p>Another thing that might seem strange is that we have to check for array appends (which are signaled by
<tt class="docutils literal"><span class="pre">zv_offset</span> <span class="pre">=</span> <span class="pre">NULL</span></tt>) in a <em>read</em> handler. This is related to <tt class="docutils literal"><span class="pre">type</span></tt> parameter that was left unused in the above
code. This parameter specifies the context in which the read occurred. For &#8220;normal&#8221; <tt class="docutils literal"><span class="pre">$foo[0]</span></tt> style reads the <tt class="docutils literal"><span class="pre">type</span></tt>
will be <tt class="docutils literal"><span class="pre">BP_VAR_R</span></tt>, but it can also be one of <tt class="docutils literal"><span class="pre">BP_VAR_W</span></tt>, <tt class="docutils literal"><span class="pre">BP_VAR_RW</span></tt>, <tt class="docutils literal"><span class="pre">BP_VAR_IS</span></tt> or <tt class="docutils literal"><span class="pre">BP_VAR_UNSET</span></tt>. To
understand when &#8220;non-read&#8221; types like this can happen consider the following examples:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>        <span class="c1">// [0] is a read_dimension(..., BP_VAR_R),     [1] is a read_dimension(..., BP_VAR_R)</span>
<span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$bar</span><span class="p">;</span> <span class="c1">// [0] is a read_dimension(..., BP_VAR_W),     [1] is a write_dimension</span>
<span class="nv">$foo</span><span class="p">[][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$bar</span><span class="p">;</span>  <span class="c1">// []  is a read_dimension(..., BP_VAR_W),     [1] is a write_dimension</span>
<span class="nb">isset</span><span class="p">(</span><span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// [0] is a read_dimension(..., BP_VAR_IS),    [1] is a has_dimension</span>
<span class="nb">unset</span><span class="p">(</span><span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// [0] is a read_dimension(..., BP_VAR_UNSET), [1] is a unset_dimension</span>
</pre></div>
</div>
<p>As you can see the other <tt class="docutils literal"><span class="pre">BP_VAR</span></tt> types occur with nested dimension access. In this case only the outermost access
calls the actual handler for the operation, the inner dimension accesses go through the read handler with the respective
type. So if the <tt class="docutils literal"><span class="pre">[]</span></tt> append operator is used in a nested access the <tt class="docutils literal"><span class="pre">read_dimension</span></tt> handler can be called with the
offset being <tt class="docutils literal"><span class="pre">NULL</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">type</span></tt> parameter can be used to change the behavior depending on the context. For example <tt class="docutils literal"><span class="pre">isset</span></tt> is usually
expected not to throw any warnings, errors or exceptions. We could honor this by explicitly checking for the
<tt class="docutils literal"><span class="pre">BP_VAR_IS</span></tt> type:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BP_VAR_IS</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">EG</span><span class="p">(</span><span class="n">uninitialized_zval_ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But as in our particular case nested dimension access doesn&#8217;t really make sense we don&#8217;t need to worry much about any
such behaviors.</p>
<p>The remaining handlers are similar to <tt class="docutils literal"><span class="pre">read_dimension</span></tt> (but less tricky):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">array_buffer_view_write_dimension</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">zv_offset</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">value</span> <span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_view_object</span> <span class="o">*</span><span class="n">intern</span> <span class="o">=</span> <span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">object</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
    <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zv_offset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Cannot append to a typed array&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">get_long_from_zval</span><span class="p">(</span><span class="n">zv_offset</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Offset is outside the buffer range&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">buffer_view_offset_set</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">array_buffer_view_has_dimension</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">zv_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check_empty</span> <span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_view_object</span> <span class="o">*</span><span class="n">intern</span> <span class="o">=</span> <span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">object</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
    <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">get_long_from_zval</span><span class="p">(</span><span class="n">zv_offset</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">check_empty</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
        <span class="n">zval</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">buffer_view_offset_get</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">zend_is_true</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">array_buffer_view_unset_dimension</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">zv_offset</span> <span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Cannot unset offsets in a typed array&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is little to say about these handlers. The only thing worth noting is the <tt class="docutils literal"><span class="pre">check_empty</span></tt> parameter of the
<tt class="docutils literal"><span class="pre">has_dimension</span></tt> handler. If this parameter is <tt class="docutils literal"><span class="pre">0</span></tt> then it&#8217;s an <tt class="docutils literal"><span class="pre">isset</span></tt> call, if it is <tt class="docutils literal"><span class="pre">1</span></tt> then it&#8217;s an <tt class="docutils literal"><span class="pre">empty</span></tt>
call. For <tt class="docutils literal"><span class="pre">isset</span></tt> the mere existence is checked, for <tt class="docutils literal"><span class="pre">empty</span></tt> the truthyness.</p>
<p>Lastly the new handlers need to be assigned in <tt class="docutils literal"><span class="pre">MINIT</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_buffer_view_handlers</span><span class="p">,</span> <span class="n">zend_get_std_object_handlers</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zend_object_handlers</span><span class="p">));</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">clone_obj</span>       <span class="o">=</span> <span class="n">array_buffer_view_clone</span><span class="p">;</span> <span class="cm">/* from previous section already */</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">read_dimension</span>  <span class="o">=</span> <span class="n">array_buffer_view_read_dimension</span><span class="p">;</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">write_dimension</span> <span class="o">=</span> <span class="n">array_buffer_view_write_dimension</span><span class="p">;</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">has_dimension</span>   <span class="o">=</span> <span class="n">array_buffer_view_has_dimension</span><span class="p">;</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">unset_dimension</span> <span class="o">=</span> <span class="n">array_buffer_view_unset_dimension</span><span class="p">;</span>
</pre></div>
</div>
<p>And now all array operations should work just as previously, only faster (for me using the handlers directly was about
four times faster than <tt class="docutils literal"><span class="pre">ArrayAccess</span></tt>).</p>
</div>
<div class="section" id="honoring-inheritance">
<h2>Honoring inheritance<a class="headerlink" href="#honoring-inheritance" title="Permalink to this headline">¶</a></h2>
<p>One key issue that has to be considered whenever you implement object handlers is that they apply all the way down the
inheritance chain. If the user extends one of the view classes it will still use the same handlers. So if the dimension
access handlers are overridden the user will no longer be able to use <tt class="docutils literal"><span class="pre">ArrayAccess</span></tt> in an inheriting class.</p>
<p>A very simple way to solve this issue is to check whether the class was extended in the dimension handlers and fall back
to the standard handlers in this case:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">intern</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">.</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">zend_get_std_object_handlers</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">read_dimension</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">zv_offset</span><span class="p">,</span> <span class="n">type</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="comparison-of-view-objects">
<h2>Comparison of view objects<a class="headerlink" href="#comparison-of-view-objects" title="Permalink to this headline">¶</a></h2>
<p>Right now view objects will always be considered equal if they are of the same type (and have no properties). That&#8217;s
not really what we want. Instead we should implement our own comparison behavior: Two buffer views should be considered
equal if they use the same buffer, with the same offset, same length and same type. Furthermore their class entry should
match (so inheriting classes aren&#8217;t considered equal). Additionally the properties should be equal, or to simplify our
implementation just shouldn&#8217;t exist. In other words: Two buffer views are equal if their internal objects are the same
byte for byte. We can easily check this with <tt class="docutils literal"><span class="pre">memcmp</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">array_buffer_view_compare_objects</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">obj1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">obj2</span> <span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_view_object</span> <span class="o">*</span><span class="n">intern1</span> <span class="o">=</span> <span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">obj1</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
    <span class="n">buffer_view_object</span> <span class="o">*</span><span class="n">intern2</span> <span class="o">=</span> <span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">obj2</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">intern1</span><span class="p">,</span> <span class="n">intern2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer_view_object</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* equal */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* not orderable */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see the <tt class="docutils literal"><span class="pre">compare_objects</span></tt> handler takes two objects and returns how those two objects relate. The return
value is one of -1 (smaller), 0 (equal) and 1 (greater).</p>
<p>In our case the smaller/greater relationship doesn&#8217;t really make sense, so we want <tt class="docutils literal"><span class="pre">$view1</span> <span class="pre">&lt;</span> <span class="pre">$view2</span></tt> and
<tt class="docutils literal"><span class="pre">$view1</span> <span class="pre">&gt;</span> <span class="pre">$view2</span></tt> to always be false. This can be done by returning 1 from the handler if the objects are not equal.
You might wonder why this works, after all 1 means &#8220;greater&#8221; so one could expect <tt class="docutils literal"><span class="pre">$view1</span> <span class="pre">&gt;</span> <span class="pre">$view2</span></tt> to return true.
The reason why this trick works is that PHP automatically translates <tt class="docutils literal"><span class="pre">$a</span> <span class="pre">&gt;</span> <span class="pre">$b</span></tt> to <tt class="docutils literal"><span class="pre">$b</span> <span class="pre">&lt;</span> <span class="pre">$a</span></tt> (and <tt class="docutils literal"><span class="pre">$a</span> <span class="pre">&gt;=</span> <span class="pre">$b</span></tt> to
<tt class="docutils literal"><span class="pre">$b</span> <span class="pre">&lt;=</span> <span class="pre">$a</span></tt>). Thus always the &#8220;less than&#8221; relationship is used and as we&#8217;re returning 1 (regardless of order) any
comparison will be false.</p>
<p>A similar comparison handler can be written for the <tt class="docutils literal"><span class="pre">ArrayBuffer</span></tt> class too.</p>
</div>
<div class="section" id="debug-information">
<h2>Debug information<a class="headerlink" href="#debug-information" title="Permalink to this headline">¶</a></h2>
<p>If you dumped a buffer view object with <tt class="docutils literal"><span class="pre">var_dump</span></tt> or <tt class="docutils literal"><span class="pre">print_r</span></tt> right now, you wouldn&#8217;t get any useful information:</p>
<div class="highlight-none"><div class="highlight"><pre>object(Int8Array)#2 (0) {
}
</pre></div>
</div>
<p>It would be much more helpful if instead the contents of the array were printed. Such a behavior can be implemented
using the <tt class="docutils literal"><span class="pre">get_debug_info</span></tt> handler:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">HashTable</span> <span class="o">*</span><span class="nf">array_buffer_view_get_debug_info</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">is_temp</span> <span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">buffer_view_object</span> <span class="o">*</span><span class="n">intern</span> <span class="o">=</span> <span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">obj</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
    <span class="n">HashTable</span> <span class="o">*</span><span class="n">props</span> <span class="o">=</span> <span class="n">Z_OBJPROP_P</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">HashTable</span> <span class="o">*</span><span class="n">ht</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
    <span class="n">ZEND_INIT_SYMTABLE_EX</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="n">zend_hash_num_elements</span><span class="p">(</span><span class="n">props</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">zend_hash_copy</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">props</span><span class="p">,</span> <span class="p">(</span><span class="n">copy_ctor_func_t</span><span class="p">)</span> <span class="n">zval_add_ref</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">));</span>

    <span class="o">*</span><span class="n">is_temp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zval</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">buffer_view_offset_get</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">zend_hash_index_update</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The handler creates a hashtable using <tt class="docutils literal"><span class="pre">ZEND_INIT_SYMTABLE_EX</span></tt> to provide a size-hint, copies the properties (in case
the user added custom properties) and then loops through the view and inserts all its elements into the hash.</p>
<p>Into the additional <tt class="docutils literal"><span class="pre">is_temp</span></tt> parameter the value <tt class="docutils literal"><span class="pre">1</span></tt> is written, signifying that we are using a temporary
hashtable that has to be freed later. Alternatively we could write <tt class="docutils literal"><span class="pre">0</span></tt> into the pointer, in which case we would have
to store the hashtable somewhere else and manually free it (you&#8217;ll find that many objects have some kind of
<tt class="docutils literal"><span class="pre">debug_info</span></tt> field in their internal structure that is used for this purpose.)</p>
<p>A small example of the kind of output this produces:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

<span class="nv">$view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Int8Array</span><span class="p">(</span><span class="nv">$buffer</span><span class="p">);</span>
<span class="nv">$view</span><span class="o">-&gt;</span><span class="na">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
<span class="nv">$view</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="nv">$view</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="nv">$view</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="nv">$view</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span><span class="p">;</span>

<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$view</span><span class="p">);</span>

<span class="c1">// outputs</span>

<span class="nx">object</span><span class="p">(</span><span class="nx">Int8Array</span><span class="p">)</span><span class="c1">#2 (5) {</span>
  <span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">string</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="s2">&quot;bar&quot;</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One more handler that could be implemented for typed arrays is <tt class="docutils literal"><span class="pre">count_elements</span></tt>, i.e. the internal equivalent of
<tt class="docutils literal"><span class="pre">Countable::count()</span></tt>. There is nothing special about that handler though, so I&#8217;m leaving this as an exercise for the
reader (just don&#8217;t forget the inheritance check!)</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="implementing_typed_arrays.html">Implementing typed arrays</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="iterators.html">Iterators</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        Send feedback to <a href="mailto:feedback@phpinternalsbook.com">feedback@phpinternalsbook.com</a>
    </div>
    
    <div class="footer">
        &copy; Copyright 2013, Julien Pauli - Anthony Ferrara - Nikita Popov.
    </div>
    <div class="footer feedback">
        All Rights Reserved
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>