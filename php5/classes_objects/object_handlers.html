<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Object handlers &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Iterators" href="iterators.html" />
    <link rel="prev" title="Implementing typed arrays" href="implementing_typed_arrays.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Object handlers</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="implementing_typed_arrays.html">Implementing typed arrays</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="iterators.html">Iterators</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="object-handlers">
<h1>Object handlers<a class="headerlink" href="#object-handlers" title="Link to this heading">¶</a></h1>
<p>In the previous sections you already had some contact with object handlers. In particular you should know how to create
the structure used to specify the handlers and how to implement cloning behavior using <code class="docutils literal notranslate"><span class="pre">clone_obj</span></code>. But this is just
the beginning: Nearly all operations on objects in PHP go through object handlers and every magic method or magic
interface is implemented with an object or class handler internally. Furthermore there are quite a few handlers which
are not exposed to userland PHP. For example internal classes can have custom comparison and cast behavior.</p>
<p>As the number of different object handlers is rather large we can only discuss examples (using the typed array
implementation from the last section) for a few of them. For all the others only a short description is provided.</p>
<section id="an-overview">
<h2>An Overview<a class="headerlink" href="#an-overview" title="Link to this heading">¶</a></h2>
<p>As of this writing there are 26 object handlers, which are listed in the following with their signature and a small
description.</p>
<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">zval</span> <span class="pre">*read_property(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*member,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">_zend_literal</span> <span class="pre">*key</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">void</span> <span class="pre">write_property(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*member,</span> <span class="pre">zval</span> <span class="pre">*value,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">_zend_literal</span> <span class="pre">*key</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">int</span> <span class="pre">has_property(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*member,</span> <span class="pre">int</span> <span class="pre">has_set_exists,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">_zend_literal</span> <span class="pre">*key</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">void</span> <span class="pre">unset_property(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*member,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">_zend_literal</span> <span class="pre">*key</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">zval</span> <span class="pre">**get_property_ptr_ptr(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*member,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">_zend_literal</span> <span class="pre">*key</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>These handlers correspond to the <code class="docutils literal notranslate"><span class="pre">__get</span></code>, <code class="docutils literal notranslate"><span class="pre">__set</span></code>, <code class="docutils literal notranslate"><span class="pre">__isset</span></code> and <code class="docutils literal notranslate"><span class="pre">__unset</span></code> methods. <code class="docutils literal notranslate"><span class="pre">get_property_ptr_ptr</span></code>
is the internal equivalent of <code class="docutils literal notranslate"><span class="pre">__get</span></code> returning by reference. The <code class="docutils literal notranslate"><span class="pre">zend_literal</span> <span class="pre">*key</span></code> passed to these functions
exists as an optimization, for example it contains a precomputed hash of the property name.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">zval</span> <span class="pre">*read_dimension(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*offset,</span> <span class="pre">int</span> <span class="pre">type</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">void</span> <span class="pre">write_dimension(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*offset,</span> <span class="pre">zval</span> <span class="pre">*value</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">int</span> <span class="pre">has_dimension(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*member,</span> <span class="pre">int</span> <span class="pre">check_empty</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">void</span> <span class="pre">unset_dimension(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">*offset</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>This set of handlers is the internal representation of the <code class="docutils literal notranslate"><span class="pre">ArrayAccess</span></code> interface.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">void</span> <span class="pre">set(zval</span> <span class="pre">**object,</span> <span class="pre">zval</span> <span class="pre">*value</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">zval</span> <span class="pre">*get(zval</span> <span class="pre">*object</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>These handlers get/set the “object value”. They can be used to override (to a certain degree) the compound
assignment operators (like <code class="docutils literal notranslate"><span class="pre">+=</span></code> or <code class="docutils literal notranslate"><span class="pre">++</span></code>) and exist mainly for the purpose of proxy objects. In practice they are
rarely used.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">HashTable</span> <span class="pre">*get_properties(zval</span> <span class="pre">*object</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">HashTable</span> <span class="pre">*get_debug_info(zval</span> <span class="pre">*object,</span> <span class="pre">int</span> <span class="pre">*is_temp</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>Used to get the object properties as a hashtable. The former is more general purpose, for example it is also used
for the <code class="docutils literal notranslate"><span class="pre">get_object_vars</span></code> function. The latter on the other hand is used exclusively to display properties in
debugging functions like <code class="docutils literal notranslate"><span class="pre">var_dump</span></code>. So even if your object does not provide any formal properties you can still
have a meaningful debug output.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">union</span> <span class="pre">_zend_function</span> <span class="pre">*get_method(zval</span> <span class="pre">**object_ptr,</span> <span class="pre">char</span> <span class="pre">*method,</span> <span class="pre">int</span> <span class="pre">method_len,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">_zend_literal</span> <span class="pre">*key</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c" id="c.call_method">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">call_method</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">method</span></span>, <span class="n"><span class="pre">INTERNAL_FUNCTION_PARAMETERS</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.call_method" title="Link to this definition">¶</a><br /></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">get_method</span></code> handler fetches the <code class="docutils literal notranslate"><span class="pre">zend_function</span></code> used to call a certain method. If there is no particular
<code class="docutils literal notranslate"><span class="pre">zend_function</span></code> that you want to invoke, but you rather want a <code class="docutils literal notranslate"><span class="pre">__call</span></code>-like catch-all behavior, then
<code class="docutils literal notranslate"><span class="pre">get_method</span></code> can signal that it is a <code class="docutils literal notranslate"><span class="pre">ZEND_OVERLOADED_FUNCTION</span></code> in which case the <code class="docutils literal notranslate"><span class="pre">call_method</span></code> handler will
be used instead.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">union</span> <span class="pre">_zend_function</span> <span class="pre">*get_constructor(zval</span> <span class="pre">*object</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">get_method</span></code>, but getting the constructor function. The most common reason to override this handler is to
disallow manual construction by throwing an error in the handler.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">int</span> <span class="pre">count_elements(zval</span> <span class="pre">*object,</span> <span class="pre">long</span> <span class="pre">*count</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>This is just the internal way of implementing the <code class="docutils literal notranslate"><span class="pre">Countable::count</span></code> method.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">int</span> <span class="pre">compare_objects(zval</span> <span class="pre">*object1,</span> <span class="pre">zval</span> <span class="pre">*object2</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">int</span> <span class="pre">cast_object(zval</span> <span class="pre">*readobj,</span> <span class="pre">zval</span> <span class="pre">*retval,</span> <span class="pre">int</span> <span class="pre">type</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>Internal classes have the ability to implement a custom compare behavior and override casting behavior for all
types. Userland classes on the other hand only have the ability to override object to string casting through
<code class="docutils literal notranslate"><span class="pre">__toString</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">int</span> <span class="pre">get_closure(zval</span> <span class="pre">*obj,</span> <span class="pre">zend_class_entry</span> <span class="pre">**ce_ptr,</span> <span class="pre">union</span> <span class="pre">_zend_function</span> <span class="pre">**fptr_ptr,</span> <span class="pre">zval</span> <span class="pre">**zobj_ptr</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>This handler is invoked when the object is used as a function, i.e. it is the internal version of <code class="docutils literal notranslate"><span class="pre">__invoke</span></code>.
The name derives from the fact that its main use is for the implementation of closures (the <code class="docutils literal notranslate"><span class="pre">Closure</span></code> class).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">zend_class_entry</span> <span class="pre">*get_class_entry(const</span> <span class="pre">zval</span> <span class="pre">*object</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">int</span> <span class="pre">get_class_name(const</span> <span class="pre">zval</span> <span class="pre">*object,</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">**class_name,</span> <span class="pre">zend_uint</span> <span class="pre">*class_name_len,</span> <span class="pre">int</span> <span class="pre">parent</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>These two handlers are used to get the class entry and class name from an object. There should be little reason to
overwrite them. The only occasion that I can think of where this would be necessary is if you choose to create a
custom object structure that does <em>not</em> contain the standard <code class="docutils literal notranslate"><span class="pre">zend_object</span></code> as a substructure. (This is entirely
possible, but not usually done.)</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">void</span> <span class="pre">add_ref(zval</span> <span class="pre">*object</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">void</span> <span class="pre">del_ref(zval</span> <span class="pre">*object</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">zend_object_value</span> <span class="pre">clone_obj(zval</span> <span class="pre">*object</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">HashTable</span> <span class="pre">*get_gc(zval</span> <span class="pre">*object,</span> <span class="pre">zval</span> <span class="pre">***table,</span> <span class="pre">int</span> <span class="pre">*n</span> <span class="pre">TSRMLS_DC)</span></span></dt>
<dd><p>This set of handlers is used for various object maintenance tasks. <code class="docutils literal notranslate"><span class="pre">add_ref</span></code> is called when a new zval starts
referencing the object, <code class="docutils literal notranslate"><span class="pre">del_ref</span></code> is called when a reference is removed. By default these handlers will change
the refcount in the object store. Once again there should be virtually no reason to overwrite them. The only
application I can think of is when you choose <em>not</em> to use the Zend object store, but rather use some custom
storage facility.</p>
<p>You already know the <code class="docutils literal notranslate"><span class="pre">clone_obj</span></code> handler, so I’ll jump right to <code class="docutils literal notranslate"><span class="pre">get_gc</span></code>: This handler should return all
variables that are held by the object, so cyclic dependencies can be properly collected.</p>
</dd></dl>

</section>
<section id="implementing-array-access-using-object-handlers">
<h2>Implementing array access using object handlers<a class="headerlink" href="#implementing-array-access-using-object-handlers" title="Link to this heading">¶</a></h2>
<p>In the previous section the <code class="docutils literal notranslate"><span class="pre">ArrayAccess</span></code> interface was used to provide array-like behavior for the buffer views. Now
we want to improve the implementation by using the respective <code class="docutils literal notranslate"><span class="pre">*_dimension</span></code> object handlers. These same handlers are
also used to implement <code class="docutils literal notranslate"><span class="pre">ArrayAccess</span></code>, but providing a custom implementation will be faster as the overhead of calling
methods is avoided.</p>
<p>The object handlers for dimensions are <code class="docutils literal notranslate"><span class="pre">read_dimension</span></code>, <code class="docutils literal notranslate"><span class="pre">write_dimension</span></code>, <code class="docutils literal notranslate"><span class="pre">has_dimension</span></code> and
<code class="docutils literal notranslate"><span class="pre">unset_dimension</span></code>. They all take the object zval as first argument and the offset zval as second. For our purposes
the offset has to be an integer, so let’s first introduce a helper function for getting the long value from a zval (in
order to avoid all the repeating cast code):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">get_long_from_zval</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">zv</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IS_LONG</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">zval</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">zv</span><span class="p">;</span>
<span class="w">        </span><span class="n">zval_copy_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">        </span><span class="n">convert_to_long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Z_LVAL</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now writing the respective handlers is rather straightforward. For example, this is how the <code class="docutils literal notranslate"><span class="pre">read_dimension</span></code> handler
looks like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="nf">array_buffer_view_read_dimension</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_offset</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">buffer_view_object</span><span class="w"> </span><span class="o">*</span><span class="n">intern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">    </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">retval</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">zv_offset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot append to a typed array&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_long_from_zval</span><span class="p">(</span><span class="n">zv_offset</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Offset is outside the buffer range&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_view_offset_get</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">    </span><span class="n">Z_DELREF_P</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Refcount should be 0 if not referenced from ext / engine */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Something that is slightly odd about this handler is the <code class="docutils literal notranslate"><span class="pre">Z_DELREF_P(retval)</span></code> at the end: <code class="docutils literal notranslate"><span class="pre">read_dimension</span></code> is
expected to return a zval with refcount 0 if the returned zval isn’t used anywhere else (as it is the case for us). The
engine will increment the refcount itself. The refcount 0 also tells the engine that reference operations on the return
value don’t make sense (as nothing would be actually modified).</p>
<p>Another thing that might seem strange is that we have to check for array appends (which are signaled by
<code class="docutils literal notranslate"><span class="pre">zv_offset</span> <span class="pre">=</span> <span class="pre">NULL</span></code>) in a <em>read</em> handler. This is related to <code class="docutils literal notranslate"><span class="pre">type</span></code> parameter that was left unused in the above
code. This parameter specifies the context in which the read occurred. For “normal” <code class="docutils literal notranslate"><span class="pre">$foo[0]</span></code> style reads the <code class="docutils literal notranslate"><span class="pre">type</span></code>
will be <code class="docutils literal notranslate"><span class="pre">BP_VAR_R</span></code>, but it can also be one of <code class="docutils literal notranslate"><span class="pre">BP_VAR_W</span></code>, <code class="docutils literal notranslate"><span class="pre">BP_VAR_RW</span></code>, <code class="docutils literal notranslate"><span class="pre">BP_VAR_IS</span></code> or <code class="docutils literal notranslate"><span class="pre">BP_VAR_UNSET</span></code>. To
understand when “non-read” types like this can happen consider the following examples:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>        <span class="c1">// [0] is a read_dimension(..., BP_VAR_R),</span>
                   <span class="c1">// [1] is a read_dimension(..., BP_VAR_R)</span>
<span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$bar</span><span class="p">;</span> <span class="c1">// [0] is a read_dimension(..., BP_VAR_W),     [1] is a write_dimension</span>
<span class="nv">$foo</span><span class="p">[][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$bar</span><span class="p">;</span>  <span class="c1">// []  is a read_dimension(..., BP_VAR_W),     [1] is a write_dimension</span>
<span class="nb">isset</span><span class="p">(</span><span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// [0] is a read_dimension(..., BP_VAR_IS),    [1] is a has_dimension</span>
<span class="nb">unset</span><span class="p">(</span><span class="nv">$foo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// [0] is a read_dimension(..., BP_VAR_UNSET), [1] is a unset_dimension</span>
</pre></div>
</div>
<p>As you can see the other <code class="docutils literal notranslate"><span class="pre">BP_VAR</span></code> types occur with nested dimension access. In this case only the outermost access
calls the actual handler for the operation, the inner dimension accesses go through the read handler with the respective
type. So if the <code class="docutils literal notranslate"><span class="pre">[]</span></code> append operator is used in a nested access the <code class="docutils literal notranslate"><span class="pre">read_dimension</span></code> handler can be called with the
offset being <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">type</span></code> parameter can be used to change the behavior depending on the context. For example <code class="docutils literal notranslate"><span class="pre">isset</span></code> is usually
expected not to throw any warnings, errors or exceptions. We could honor this by explicitly checking for the
<code class="docutils literal notranslate"><span class="pre">BP_VAR_IS</span></code> type:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BP_VAR_IS</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">EG</span><span class="p">(</span><span class="n">uninitialized_zval_ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But as in our particular case nested dimension access doesn’t really make sense we don’t need to worry much about any
such behaviors.</p>
<p>The remaining handlers are similar to <code class="docutils literal notranslate"><span class="pre">read_dimension</span></code> (but less tricky):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">array_buffer_view_write_dimension</span><span class="p">(</span>
<span class="w">    </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_offset</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="n">TSRMLS_DC</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">buffer_view_object</span><span class="w"> </span><span class="o">*</span><span class="n">intern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">zv_offset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot append to a typed array&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_long_from_zval</span><span class="p">(</span><span class="n">zv_offset</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Offset is outside the buffer range&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">buffer_view_offset_set</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">array_buffer_view_has_dimension</span><span class="p">(</span>
<span class="w">    </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_offset</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">check_empty</span><span class="w"> </span><span class="n">TSRMLS_DC</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">buffer_view_object</span><span class="w"> </span><span class="o">*</span><span class="n">intern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">object</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_long_from_zval</span><span class="p">(</span><span class="n">zv_offset</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check_empty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span>
<span class="w">        </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_view_offset_get</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">        </span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_is_true</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">        </span><span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">array_buffer_view_unset_dimension</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_offset</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">zend_throw_exception</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot unset offsets in a typed array&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is little to say about these handlers. The only thing worth noting is the <code class="docutils literal notranslate"><span class="pre">check_empty</span></code> parameter of the
<code class="docutils literal notranslate"><span class="pre">has_dimension</span></code> handler. If this parameter is <code class="docutils literal notranslate"><span class="pre">0</span></code> then it’s an <code class="docutils literal notranslate"><span class="pre">isset</span></code> call, if it is <code class="docutils literal notranslate"><span class="pre">1</span></code> then it’s an <code class="docutils literal notranslate"><span class="pre">empty</span></code>
call. For <code class="docutils literal notranslate"><span class="pre">isset</span></code> the mere existence is checked, for <code class="docutils literal notranslate"><span class="pre">empty</span></code> the truthyness.</p>
<p>Lastly the new handlers need to be assigned in <code class="docutils literal notranslate"><span class="pre">MINIT</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_buffer_view_handlers</span><span class="p">,</span><span class="w"> </span><span class="n">zend_get_std_object_handlers</span><span class="p">(),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">zend_object_handlers</span><span class="p">));</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">clone_obj</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">array_buffer_view_clone</span><span class="p">;</span><span class="w"> </span><span class="cm">/* from previous section */</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">read_dimension</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">array_buffer_view_read_dimension</span><span class="p">;</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">write_dimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_buffer_view_write_dimension</span><span class="p">;</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">has_dimension</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">array_buffer_view_has_dimension</span><span class="p">;</span>
<span class="n">array_buffer_view_handlers</span><span class="p">.</span><span class="n">unset_dimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_buffer_view_unset_dimension</span><span class="p">;</span>
</pre></div>
</div>
<p>And now all array operations should work just as previously, only faster (for me using the handlers directly was about
four times faster than <code class="docutils literal notranslate"><span class="pre">ArrayAccess</span></code>).</p>
</section>
<section id="honoring-inheritance">
<h2>Honoring inheritance<a class="headerlink" href="#honoring-inheritance" title="Link to this heading">¶</a></h2>
<p>One key issue that has to be considered whenever you implement object handlers is that they apply all the way down the
inheritance chain. If the user extends one of the view classes it will still use the same handlers. So if the dimension
access handlers are overridden the user will no longer be able to use <code class="docutils literal notranslate"><span class="pre">ArrayAccess</span></code> in an inheriting class.</p>
<p>A very simple way to solve this issue is to check whether the class was extended in the dimension handlers and fall back
to the standard handlers in this case:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">intern</span><span class="o">-&gt;</span><span class="n">std</span><span class="p">.</span><span class="n">ce</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">zend_get_std_object_handlers</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">read_dimension</span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">zv_offset</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="comparison-of-view-objects">
<h2>Comparison of view objects<a class="headerlink" href="#comparison-of-view-objects" title="Link to this heading">¶</a></h2>
<p>Right now view objects will always be considered equal if they are of the same type (and have no properties). That’s
not really what we want. Instead we should implement our own comparison behavior: Two buffer views should be considered
equal if they use the same buffer, with the same offset, same length and same type. Furthermore their class entry should
match (so inheriting classes aren’t considered equal). Additionally the properties should be equal, or to simplify our
implementation just shouldn’t exist. In other words: Two buffer views are equal if their internal objects are the same
byte for byte. We can easily check this with <code class="docutils literal notranslate"><span class="pre">memcmp</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">array_buffer_view_compare_objects</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">obj1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">obj2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">buffer_view_object</span><span class="w"> </span><span class="o">*</span><span class="n">intern1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">obj1</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">    </span><span class="n">buffer_view_object</span><span class="w"> </span><span class="o">*</span><span class="n">intern2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">obj2</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">intern1</span><span class="p">,</span><span class="w"> </span><span class="n">intern2</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer_view_object</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* equal */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* not orderable */</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see the <code class="docutils literal notranslate"><span class="pre">compare_objects</span></code> handler takes two objects and returns how those two objects relate. The return
value is one of -1 (smaller), 0 (equal) and 1 (greater).</p>
<p>In our case the smaller/greater relationship doesn’t really make sense, so we want <code class="docutils literal notranslate"><span class="pre">$view1</span> <span class="pre">&lt;</span> <span class="pre">$view2</span></code> and
<code class="docutils literal notranslate"><span class="pre">$view1</span> <span class="pre">&gt;</span> <span class="pre">$view2</span></code> to always be false. This can be done by returning 1 from the handler if the objects are not equal.
You might wonder why this works, after all 1 means “greater” so one could expect <code class="docutils literal notranslate"><span class="pre">$view1</span> <span class="pre">&gt;</span> <span class="pre">$view2</span></code> to return true.
The reason why this trick works is that PHP automatically translates <code class="docutils literal notranslate"><span class="pre">$a</span> <span class="pre">&gt;</span> <span class="pre">$b</span></code> to <code class="docutils literal notranslate"><span class="pre">$b</span> <span class="pre">&lt;</span> <span class="pre">$a</span></code> (and <code class="docutils literal notranslate"><span class="pre">$a</span> <span class="pre">&gt;=</span> <span class="pre">$b</span></code> to
<code class="docutils literal notranslate"><span class="pre">$b</span> <span class="pre">&lt;=</span> <span class="pre">$a</span></code>). Thus always the “less than” relationship is used and as we’re returning 1 (regardless of order) any
comparison will be false.</p>
<p>A similar comparison handler can be written for the <code class="docutils literal notranslate"><span class="pre">ArrayBuffer</span></code> class too.</p>
</section>
<section id="debug-information">
<h2>Debug information<a class="headerlink" href="#debug-information" title="Link to this heading">¶</a></h2>
<p>If you dumped a buffer view object with <code class="docutils literal notranslate"><span class="pre">var_dump</span></code> or <code class="docutils literal notranslate"><span class="pre">print_r</span></code> right now, you wouldn’t get any useful information:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>object(Int8Array)#2 (0) {
}
</pre></div>
</div>
<p>It would be much more helpful if instead the contents of the array were printed. Such a behavior can be implemented
using the <code class="docutils literal notranslate"><span class="pre">get_debug_info</span></code> handler:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">HashTable</span><span class="w"> </span><span class="o">*</span><span class="nf">array_buffer_view_get_debug_info</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">is_temp</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">buffer_view_object</span><span class="w"> </span><span class="o">*</span><span class="n">intern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_object_store_get_object</span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>
<span class="w">    </span><span class="n">HashTable</span><span class="w"> </span><span class="o">*</span><span class="n">props</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Z_OBJPROP_P</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">    </span><span class="n">HashTable</span><span class="w"> </span><span class="o">*</span><span class="n">ht</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="n">ALLOC_HASHTABLE</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
<span class="w">    </span><span class="n">ZEND_INIT_SYMTABLE_EX</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span><span class="w"> </span><span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">zend_hash_num_elements</span><span class="p">(</span><span class="n">props</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">zend_hash_copy</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span><span class="w"> </span><span class="n">props</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">copy_ctor_func_t</span><span class="p">)</span><span class="w"> </span><span class="n">zval_add_ref</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>

<span class="w">    </span><span class="o">*</span><span class="n">is_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">intern</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_view_offset_get</span><span class="p">(</span><span class="n">intern</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">zend_hash_index_update</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The handler creates a hashtable using <code class="docutils literal notranslate"><span class="pre">ZEND_INIT_SYMTABLE_EX</span></code> to provide a size-hint, copies the properties (in case
the user added custom properties) and then loops through the view and inserts all its elements into the hash.</p>
<p>Into the additional <code class="docutils literal notranslate"><span class="pre">is_temp</span></code> parameter the value <code class="docutils literal notranslate"><span class="pre">1</span></code> is written, signifying that we are using a temporary
hashtable that has to be freed later. Alternatively we could write <code class="docutils literal notranslate"><span class="pre">0</span></code> into the pointer, in which case we would have
to store the hashtable somewhere else and manually free it (you’ll find that many objects have some kind of
<code class="docutils literal notranslate"><span class="pre">debug_info</span></code> field in their internal structure that is used for this purpose.)</p>
<p>A small example of the kind of output this produces:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

<span class="nv">$view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Int8Array</span><span class="p">(</span><span class="nv">$buffer</span><span class="p">);</span>
<span class="nv">$view</span><span class="o">-&gt;</span><span class="na">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
<span class="nv">$view</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="nv">$view</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="nv">$view</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="nv">$view</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span><span class="p">;</span>

<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$view</span><span class="p">);</span>

<span class="c1">// outputs</span>

<span class="nx">object</span><span class="p">(</span><span class="nx">Int8Array</span><span class="p">)</span><span class="c1">#2 (5) {</span>
  <span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">string</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="s2">&quot;bar&quot;</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=&gt;</span>
  <span class="nx">int</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One more handler that could be implemented for typed arrays is <code class="docutils literal notranslate"><span class="pre">count_elements</span></code>, i.e. the internal equivalent of
<code class="docutils literal notranslate"><span class="pre">Countable::count()</span></code>. There is nothing special about that handler though, so I’m leaving this as an exercise for the
reader (just don’t forget the inheritance check!)</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="implementing_typed_arrays.html">Implementing typed arrays</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="iterators.html">Iterators</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>