<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Basic structure &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Hashtable API" href="hashtable_api.html" />
    <link rel="prev" title="Hashtables" href="../hashtables.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Basic structure</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="../hashtables.html">Hashtables</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="hashtable_api.html">Hashtable API</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="basic-structure">
<h1>Basic structure<a class="headerlink" href="#basic-structure" title="Link to this heading">¶</a></h1>
<section id="basic-concepts">
<h2>Basic concepts<a class="headerlink" href="#basic-concepts" title="Link to this heading">¶</a></h2>
<p>Arrays in C are just regions of memory that can be accessed by offset. This implies that keys have to be integers and
need to be continuous. For example, if you have the keys 0, 1 and 2, then the next key has to be 3 and can’t be
214678462. PHP arrays are very different: They support both string keys and non-continuous integer keys and even allow
mixing both.</p>
<p>To implement such a structure in C there are two approaches: The first is using a binary search tree, where both lookup
and insert have complexity <code class="docutils literal notranslate"><span class="pre">O(log</span> <span class="pre">n)</span></code> (where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of elements in the table). The second is a hashtable,
which has an average lookup/insert complexity of <code class="docutils literal notranslate"><span class="pre">O(1)</span></code>, i.e. elements can be inserted and retrieved in constant time.
As such hashtables are preferable in most cases and are also the technique that PHP uses.</p>
<p>The idea behind a hashtable is very simple: A complex key value (like a string) is converted into an integer using a
hash function. This integer can then be used as an offset into a normal C array. The issue is that the number of
integers (<code class="docutils literal notranslate"><span class="pre">2^32</span></code> or <code class="docutils literal notranslate"><span class="pre">2^64</span></code>) is much smaller than the number of strings (of which there are infinitely many). As such
the hash function will have collisions, i.e. cases where two strings have the same hash value.</p>
<p>As such some kind of collision resolution has to take place. There are basically two solutions to this problem, the
first being <em>open addressing</em> (which is not covered here). The second one is <em>chaining</em> and is employed by PHP. This
method simply stores all elements having the same hash in a linked list. When a key is looked up PHP will calculate the
hash and then go through the linked list of “possible” values until it finds the matching entry. Here is an
illustration of chaining collision resolution:</p>
<a class="reference internal image-reference" href="../../_images/basic_hashtable.svg"><img alt="../../_images/basic_hashtable.svg" class="align-center" src="../../_images/basic_hashtable.svg" style="height: 265px;" />
</a>
<p>The elements of the linked list are called <code class="docutils literal notranslate"><span class="pre">Bucket</span></code>s and the C array containing the heads of the linked lists is
called <code class="docutils literal notranslate"><span class="pre">arBuckets</span></code>.</p>
<p>Consider how you would delete an element from such a structure: Say you have a pointer to the bucket of <code class="docutils literal notranslate"><span class="pre">&quot;c&quot;</span></code> and want
to remove it. To do this you’d have to set the pointer coming from <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Thus you need to retrieve the
bucket of <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code> which you can do either by traversing the linked list for the hash value or by additionally storing
pointers in the reverse direction. The latter is what PHP does: Every bucket contains both a pointer to the next bucket
(<code class="docutils literal notranslate"><span class="pre">pNext</span></code>) and the previous bucket (<code class="docutils literal notranslate"><span class="pre">pLast</span></code>). This is illustrated in the following graphic:</p>
<a class="reference internal image-reference" href="../../_images/doubly_linked_hashtable.svg"><img alt="../../_images/doubly_linked_hashtable.svg" class="align-center" src="../../_images/doubly_linked_hashtable.svg" style="height: 250px;" />
</a>
<p>Furthermore PHP hashtables are <em>ordered</em>: If you traverse an array you’ll get the elements in same order in which you
inserted them. To support this the buckets have to be part of another linked list which specifies the order. This is
once again a doubly linked list, for the same reasons as outlined above (and to support traversation in reverse order).
The forward pointers are stored in <code class="docutils literal notranslate"><span class="pre">pListNext</span></code>, the backward pointers in <code class="docutils literal notranslate"><span class="pre">pListLast</span></code>. Additionally the hashtable
structure has a pointer to the start of the list (<code class="docutils literal notranslate"><span class="pre">pListHead</span></code>) and the end of the list (<code class="docutils literal notranslate"><span class="pre">pListLast</span></code>). Here is an
example of how this linked list could look like for the elements <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;c&quot;</span></code> (in that order):</p>
<a class="reference internal image-reference" href="../../_images/ordered_hashtable.svg"><img alt="../../_images/ordered_hashtable.svg" class="align-center" src="../../_images/ordered_hashtable.svg" style="height: 250px;" />
</a>
</section>
<section id="the-hashtable-and-bucket-structures">
<h2>The HashTable and Bucket structures<a class="headerlink" href="#the-hashtable-and-bucket-structures" title="Link to this heading">¶</a></h2>
<p>To implement hashtables PHP uses two structures, which can be found in the <code class="docutils literal notranslate"><span class="pre">zend_hash.h</span></code> file. We’ll first have a look
at the <code class="docutils literal notranslate"><span class="pre">Bucket</span></code> struct:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">bucket</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">nKeyLength</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pData</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pDataPtr</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bucket</span><span class="w"> </span><span class="o">*</span><span class="n">pListNext</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bucket</span><span class="w"> </span><span class="o">*</span><span class="n">pListLast</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bucket</span><span class="w"> </span><span class="o">*</span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bucket</span><span class="w"> </span><span class="o">*</span><span class="n">pLast</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">arKey</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Bucket</span><span class="p">;</span>
</pre></div>
</div>
<p>You already know what the <code class="docutils literal notranslate"><span class="pre">pNext</span></code>, <code class="docutils literal notranslate"><span class="pre">pLast</span></code>, <code class="docutils literal notranslate"><span class="pre">pListNext</span></code> and <code class="docutils literal notranslate"><span class="pre">pListLast</span></code> pointers are for. Let’s quickly go
through the remaining members:</p>
<p><code class="docutils literal notranslate"><span class="pre">h</span></code> is the hash of the key. If the key is an integer, then <code class="docutils literal notranslate"><span class="pre">h</span></code> will be that integer (for integers the hash function
doesn’t do anything) and <code class="docutils literal notranslate"><span class="pre">nKeyLength</span></code> will be 0. For string keys <code class="docutils literal notranslate"><span class="pre">h</span></code> will be the result of <code class="docutils literal notranslate"><span class="pre">zend_hash_func()</span></code>,
<code class="docutils literal notranslate"><span class="pre">arKey</span></code> will hold the string and <code class="docutils literal notranslate"><span class="pre">nKeyLength</span></code> its length.</p>
<p><code class="docutils literal notranslate"><span class="pre">pData</span></code> is a pointer to the stored value. The stored value will not be the same as the one passed to the insertion
function, rather it will be a copy of it (which is allocated separately from the bucket). As this would be very
inefficient when the stored value is a pointer PHP employs a small trick: Instead of storing the pointer in a separate
allocation it is put into the <code class="docutils literal notranslate"><span class="pre">pDataPtr</span></code> member. <code class="docutils literal notranslate"><span class="pre">pData</span></code> then points to that member (<code class="docutils literal notranslate"><span class="pre">pData</span> <span class="pre">=</span> <span class="pre">&amp;pDataPtr</span></code>).</p>
<p>Let’s have a look at the main <code class="docutils literal notranslate"><span class="pre">HashTable</span></code> struct now:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_hashtable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">nTableSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">nTableMask</span><span class="p">;</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">nNumOfElements</span><span class="p">;</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">nNextFreeElement</span><span class="p">;</span>
<span class="w">    </span><span class="n">Bucket</span><span class="w"> </span><span class="o">*</span><span class="n">pInternalPointer</span><span class="p">;</span>
<span class="w">    </span><span class="n">Bucket</span><span class="w"> </span><span class="o">*</span><span class="n">pListHead</span><span class="p">;</span>
<span class="w">    </span><span class="n">Bucket</span><span class="w"> </span><span class="o">*</span><span class="n">pListTail</span><span class="p">;</span>
<span class="w">    </span><span class="n">Bucket</span><span class="w"> </span><span class="o">**</span><span class="n">arBuckets</span><span class="p">;</span>
<span class="w">    </span><span class="n">dtor_func_t</span><span class="w"> </span><span class="n">pDestructor</span><span class="p">;</span>
<span class="w">    </span><span class="n">zend_bool</span><span class="w"> </span><span class="n">persistent</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">nApplyCount</span><span class="p">;</span>
<span class="w">    </span><span class="n">zend_bool</span><span class="w"> </span><span class="n">bApplyProtection</span><span class="p">;</span>
<span class="cp">#if ZEND_DEBUG</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">inconsistent</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"> </span><span class="n">HashTable</span><span class="p">;</span>
</pre></div>
</div>
<p>You already know that <code class="docutils literal notranslate"><span class="pre">arBuckets</span></code> is the C array that contains the linked bucket lists and is indexed by the hash of
the key. As PHP arrays don’t have a fixed size <code class="docutils literal notranslate"><span class="pre">arBuckets</span></code> has to be dynamically resized when the number of elements
in the table (<code class="docutils literal notranslate"><span class="pre">nNumOfElements</span></code>) surpasses the current size of the <code class="docutils literal notranslate"><span class="pre">arBuckets</span></code> allocation (<code class="docutils literal notranslate"><span class="pre">nTableSize</span></code>). We could
of course store more than <code class="docutils literal notranslate"><span class="pre">nTableSize</span></code> elements in the hashtable, but this would increase the number of collisions
and thus degrade performance.</p>
<p><code class="docutils literal notranslate"><span class="pre">nTableSize</span></code> is always a power of two, so if you have 12 elements in a hashtable the actual table size will be 16.
Note though that while the <code class="docutils literal notranslate"><span class="pre">arBuckets</span></code> array automatically grows, it will <em>not</em> shrink when you remove elements. If
you first insert 1000000 elements into the hashtable and then remove all of them again the <code class="docutils literal notranslate"><span class="pre">nTableSize</span></code> will still
be 1048576.</p>
<p>The result of the hash function is a <code class="docutils literal notranslate"><span class="pre">ulong</span></code>, but the <code class="docutils literal notranslate"><span class="pre">nTableSize</span></code> will usually be a lot smaller than that. Thus
the hash can not be directly used to index into the <code class="docutils literal notranslate"><span class="pre">arBuckets</span></code> array. Instead <code class="docutils literal notranslate"><span class="pre">nIndex</span> <span class="pre">=</span> <span class="pre">h</span> <span class="pre">%</span> <span class="pre">nTableSize</span></code> is used.
As the table size is always a power of two this expression is equivalent to <code class="docutils literal notranslate"><span class="pre">nIndex</span> <span class="pre">=</span> <span class="pre">h</span> <span class="pre">&amp;</span> <span class="pre">(nTableSize</span> <span class="pre">-</span> <span class="pre">1)</span></code>. To see
why let’s see how <code class="docutils literal notranslate"><span class="pre">nTableSize</span> <span class="pre">-</span> <span class="pre">1</span></code> changes the value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nTableSize     = 128 = 0b00000000.00000000.00000000.10000000
nTableSize - 1 = 127 = 0b00000000.00000000.00000000.01111111
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nTableSize</span> <span class="pre">-</span> <span class="pre">1</span></code> has all bits below the table size set. Thus doing <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">&amp;</span> <span class="pre">(nTableSize</span> <span class="pre">-</span> <span class="pre">1)</span></code> will only keep the bits
of the hash that are lower than <code class="docutils literal notranslate"><span class="pre">nTableSize</span></code>, which is the same thing <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">%</span> <span class="pre">nTableSize</span></code> does.</p>
<p>The value <code class="docutils literal notranslate"><span class="pre">nTableSize</span> <span class="pre">-</span> <span class="pre">1</span></code> is called the table mask and stored in the <code class="docutils literal notranslate"><span class="pre">nTableMask</span></code> member. Using a masking operation
instead of a modulus is just a performance optimization.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nNextFreeElement</span></code> member specifies the next integer key that will be used when you insert an element using
<code class="docutils literal notranslate"><span class="pre">$array[]</span> <span class="pre">=</span> <span class="pre">$value</span></code>. It will be one larger than the largest integer key that was ever used in this hashtable.</p>
<p>You already know the role of the <code class="docutils literal notranslate"><span class="pre">pListHead</span></code> and <code class="docutils literal notranslate"><span class="pre">pListTail</span></code> pointers (they are the head/tail of the doubly linked
list specifying the order). The <code class="docutils literal notranslate"><span class="pre">pInternalPointer</span></code> is used for iteration and points to the “current” bucket.</p>
<p>When an item is deleted from the hashtable a destruction function can be called for it, which is stored in the
<code class="docutils literal notranslate"><span class="pre">pDestructor</span></code> member. For example, if you are storing <code class="docutils literal notranslate"><span class="pre">zval</span> <span class="pre">*</span></code> items in the hashtable, you will probably want
<code class="docutils literal notranslate"><span class="pre">zval_ptr_dtor</span></code> to be called when an element is removed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">persistent</span></code> flag specified whether the buckets (and their values) should use persistent allocation. For most
use cases this will be <code class="docutils literal notranslate"><span class="pre">0</span></code> as the hashtable is not supposed to live longer than one request. The <code class="docutils literal notranslate"><span class="pre">bApplyProtection</span></code>
flag specifies whether the hashtable should use recursion protection (defaults to 1). Recursion protection will throw
an error if the recursion depth (stored in <code class="docutils literal notranslate"><span class="pre">nApplyCount</span></code>) reaches a certain level. The protection is used for
hashtable comparisons and for the <code class="docutils literal notranslate"><span class="pre">zend_hash_apply</span></code> functions.</p>
<p>The last member <code class="docutils literal notranslate"><span class="pre">inconsistent</span></code> is only used in debug builds and stores information on the current state of the
hashtable. This is used to throw errors for some incorrect usages of the hashtable, e.g. if you access a hashtable that
is in the process of being destroyed.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="../hashtables.html">Hashtables</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="hashtable_api.html">Hashtable API</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>