<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Casts and operations &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Hashtables" href="../hashtables.html" />
    <link rel="prev" title="Memory management" href="memory_management.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Casts and operations</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../hashtables.html">Hashtables</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="casts-and-operations">
<h1>Casts and operations<a class="headerlink" href="#casts-and-operations" title="Link to this heading">¶</a></h1>
<section id="basic-operations">
<h2>Basic operations<a class="headerlink" href="#basic-operations" title="Link to this heading">¶</a></h2>
<p>As zvals are complex structures you can’t directly perform basic operations like <code class="docutils literal notranslate"><span class="pre">zv1</span> <span class="pre">+</span> <span class="pre">zv2</span></code> on them. Doing something
like this will either give you an error or end up adding together two pointers rather than their values.</p>
<p>The “basic” operations like <code class="docutils literal notranslate"><span class="pre">+</span></code> are rather complicated when working with zvals, because they have to work across
many types. For example PHP allows you to add together a double with a string containing an integer (<code class="docutils literal notranslate"><span class="pre">3.14</span> <span class="pre">+</span> <span class="pre">&quot;17&quot;</span></code>)
or even adding two arrays (<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">+</span> <span class="pre">[4,</span> <span class="pre">5,</span> <span class="pre">6]</span></code>).</p>
<p>For this reason PHP provides special functions for performing operations on zvals. Addition for example is handled by
<code class="docutils literal notranslate"><span class="pre">add_function()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

<span class="n">ZVAL_DOUBLE</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;17&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="cm">/* result = a + b */</span>
<span class="n">add_function</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%Z</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"> </span><span class="cm">/* 20.14 */</span>

<span class="cm">/* zvals a, b, result need to be dtored */</span>
</pre></div>
</div>
<p>Apart from <code class="docutils literal notranslate"><span class="pre">add_function()</span></code> there are several other functions implementing binary (two-operand) operations, all with
the same signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">add_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">                 </span><span class="cm">/*  +  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sub_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">                 </span><span class="cm">/*  -  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">mul_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">                 </span><span class="cm">/*  *  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">div_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">                 </span><span class="cm">/*  /  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">mod_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">                 </span><span class="cm">/*  %  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">concat_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">              </span><span class="cm">/*  .  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">bitwise_or_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">          </span><span class="cm">/*  |  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">bitwise_and_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">         </span><span class="cm">/*  &amp;  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">bitwise_xor_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">         </span><span class="cm">/*  ^  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">shift_left_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">          </span><span class="cm">/*  &lt;&lt; */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">shift_right_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">         </span><span class="cm">/*  &gt;&gt; */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">boolean_xor_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">         </span><span class="cm">/* xor */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">is_equal_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">            </span><span class="cm">/*  == */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">is_not_equal_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">        </span><span class="cm">/*  != */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">is_identical_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">        </span><span class="cm">/* === */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">is_not_identical_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">    </span><span class="cm">/* !== */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">is_smaller_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w">          </span><span class="cm">/*  &lt;  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">is_smaller_or_equal_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w"> </span><span class="cm">/*  &lt;= */</span>
</pre></div>
</div>
<p>All functions take a <code class="docutils literal notranslate"><span class="pre">result</span></code> zval into which the result of the operation on <code class="docutils literal notranslate"><span class="pre">op1</span></code> and <code class="docutils literal notranslate"><span class="pre">op2</span></code> is stored. The
<code class="docutils literal notranslate"><span class="pre">int</span></code> return value is either <code class="docutils literal notranslate"><span class="pre">SUCCESS</span></code> or <code class="docutils literal notranslate"><span class="pre">FAILURE</span></code> and indicates whether the operation was successful. Note that
<code class="docutils literal notranslate"><span class="pre">result</span></code> will always be set to some value (like <code class="docutils literal notranslate"><span class="pre">false</span></code>) even if the operations was not successful.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">result</span></code> zval needs to be allocated and initialized prior to calling one of the functions. Alternatively
<code class="docutils literal notranslate"><span class="pre">result</span></code> and <code class="docutils literal notranslate"><span class="pre">op1</span></code> can be the same, in which case effectively a compound assignment operation is performed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="n">ZVAL_LONG</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">);</span>

<span class="cm">/* a += b */</span>
<span class="n">add_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%Z</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="cm">/* 45 */</span>

<span class="cm">/* zvals a, b need to be dtored */</span>
</pre></div>
</div>
<p>Some binary operators are missing from the above list. For example there are no functions for <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>. The
reason behind this is that you can implement them using <code class="docutils literal notranslate"><span class="pre">is_smaller_function()</span></code> and <code class="docutils literal notranslate"><span class="pre">is_smaller_or_equal_function()</span></code>
simply by swapping the operands.</p>
<p>Also missing from the list are functions for performing <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code>. The reasoning here is that the main feature
those operators provide is short-circuiting, which you can’t implement with a simple function. If you take
short-circuiting away, both operators are just boolean casts followed by a <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> or <code class="docutils literal notranslate"><span class="pre">||</span></code> C-operation.</p>
<p>Apart from the binary operators there are also two unary (single operand) functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">boolean_not_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w"> </span><span class="cm">/*  !  */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">bitwise_not_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span><span class="w"> </span><span class="cm">/*  ~  */</span>
</pre></div>
</div>
<p>They work in the same way the other functions, but accept only one operand. The unary <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> operations are
missing, because they can be implemented as <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">$value</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">$value</span></code> respectively, by making use of
<code class="docutils literal notranslate"><span class="pre">add_function()</span></code> and <code class="docutils literal notranslate"><span class="pre">sub_function()</span></code>.</p>
<p>The last two functions implement the <code class="docutils literal notranslate"><span class="pre">++</span></code> and <code class="docutils literal notranslate"><span class="pre">--</span></code> operators:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">increment_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">);</span><span class="w"> </span><span class="cm">/* ++ */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">decrement_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">);</span><span class="w"> </span><span class="cm">/* -- */</span>
</pre></div>
</div>
<p>These functions don’t take a result zval and instead directly modify the passed operand. Note that using these is
different from performing a <code class="docutils literal notranslate"><span class="pre">+</span> <span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">1</span></code> with <code class="docutils literal notranslate"><span class="pre">add_function()</span></code>/<code class="docutils literal notranslate"><span class="pre">sub_function()</span></code>. For example incrementing
<code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code> will result in <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code>, but adding <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span> <span class="pre">+</span> <span class="pre">1</span></code> will result in <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</section>
<section id="comparisons">
<h2>Comparisons<a class="headerlink" href="#comparisons" title="Link to this heading">¶</a></h2>
<p>The comparison functions introduced above all perform some specific operation, e.g. <code class="docutils literal notranslate"><span class="pre">is_equal_function()</span></code> corresponds
to <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">is_smaller_function()</span></code> performs a <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>. An alternative to these is <code class="docutils literal notranslate"><span class="pre">compare_function()</span></code> which
computes a more generic result:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

<span class="n">ZVAL_LONG</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;24&quot;</span><span class="p">);</span>

<span class="n">compare_function</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">TSRMLS_CC</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;a is smaller than b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;a is greater than b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="cm">/*if (Z_LVAL_P(result) == 0)*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;a is equal to b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* zvals a, b, result need to be dtored */</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">compare_function()</span></code> will set the <code class="docutils literal notranslate"><span class="pre">result</span></code> zval to one of -1, 1 or 0 corresponding to the relations “smaller than”,
“greater than” or “equal” between the passed values. It is also part of a larger family of comparison functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">compare_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">numeric_compare_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">string_compare_function_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">,</span><span class="w"> </span><span class="n">zend_bool</span><span class="w"> </span><span class="n">case_insensitive</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">string_compare_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">string_case_compare_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span>

<span class="cp">#ifdef HAVE_STRCOLL</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">string_locale_compare_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Once again all functions accept two operands and a result zval and return <code class="docutils literal notranslate"><span class="pre">SUCCESS</span></code>/<code class="docutils literal notranslate"><span class="pre">FAILURE</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">compare_function()</span></code> performs a “normal” PHP comparison (i.e. it behaves the same way as the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code>
operators). <code class="docutils literal notranslate"><span class="pre">numeric_compare_function()</span></code> compares the operands as numbers by casting them to doubles first.</p>
<p><code class="docutils literal notranslate"><span class="pre">string_compare_function_ex()</span></code> compares the operands as strings and has a flag that indicates whether the comparison
should be <code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code>. Instead of manually specifying that flag you can also use
<code class="docutils literal notranslate"><span class="pre">string_compare_function()</span></code> (case sensitive) or <code class="docutils literal notranslate"><span class="pre">string_case_compare_function()</span></code> (case insensitive). The string
comparison done by these functions is a normal lexicographical string comparison without additional magic for numeric
strings.</p>
<p><code class="docutils literal notranslate"><span class="pre">string_locale_compare_function()</span></code> performs a string comparison according to the current locale and is only available
if <code class="docutils literal notranslate"><span class="pre">HAVE_STRCOLL</span></code> is defined. As such you must use <code class="docutils literal notranslate"><span class="pre">#ifdef</span> <span class="pre">HAVE_STRCOLL</span></code> guards whenever you employ the function.
As with anything related to locales, it’s best to avoid its use.</p>
</section>
<section id="casts">
<h2>Casts<a class="headerlink" href="#casts" title="Link to this heading">¶</a></h2>
<p>When implementing your own code you will very often deal with only one particular type of zval. E.g. if you are
implementing some string handling code, you’ll want to deal only with string zvals and not bother with everything else.
On the other hand you likely also want to support PHPs dynamic type system: PHP allows you to work with numbers as
strings and extension code should honor this as well.</p>
<p>The solution is to cast a zval of arbitrary type to the specific type you’ll be working with. In order to support this
PHP provides a <code class="docutils literal notranslate"><span class="pre">convert_to_*</span></code> function for every type (apart from resources, as there is no <code class="docutils literal notranslate"><span class="pre">(resource)</span></code> cast):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_null</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_boolean</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_long</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_double</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_string</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_array</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_object</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_long_base</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">base</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_cstring</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>The last two functions implement non-standard casts: <code class="docutils literal notranslate"><span class="pre">convert_to_long_base()</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">convert_to_long()</span></code>,
but it will make use of a particular base for string to long conversions (e.g. <code class="docutils literal notranslate"><span class="pre">16</span></code> for hexadecimals).
<code class="docutils literal notranslate"><span class="pre">convert_to_cstring()</span></code> behaves like <code class="docutils literal notranslate"><span class="pre">convert_to_string()</span></code> but uses a locale-independent double to string conversion.
This means that the result will always use <code class="docutils literal notranslate"><span class="pre">.</span></code> as the decimal separator rather than creating locale-specific strings
like <code class="docutils literal notranslate"><span class="pre">&quot;3,14&quot;</span></code> (Germany).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">convert_to_*</span></code> functions will directly modify the passed zval:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;123 foobar&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="n">convert_to_long</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>

<span class="n">zval_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>If the zval is used in more than one place (refcount &gt; 1) chances are that directly modifying it would result in
incorrect behavior. E.g. if you receive a zval by-value and directly apply a <code class="docutils literal notranslate"><span class="pre">convert_to_*</span></code> function to it, you will
modify not only the reference to the zval inside the function but also the reference outside of it.</p>
<p>To solve this issue PHP provides an additional set of <code class="docutils literal notranslate"><span class="pre">convert_to_*_ex</span></code> macros:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_null_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_boolean_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_long_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_double_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_string_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_array_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_object_ex</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
</pre></div>
</div>
<p>These macros take a <code class="docutils literal notranslate"><span class="pre">zval**</span></code> and are implemented by performing a <code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL_IF_NOT_REF()</span></code> before the type
conversion:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define convert_to_ex_master(ppzv, lower_type, upper_type)  \</span>
<span class="cp">    if (Z_TYPE_PP(ppzv)!=IS_##upper_type) {                 \</span>
<span class="cp">        SEPARATE_ZVAL_IF_NOT_REF(ppzv);                     \</span>
<span class="cp">        convert_to_##lower_type(*ppzv);                     \</span>
<span class="cp">    }</span>
</pre></div>
</div>
<p>Apart from this the usage is similar to the normal <code class="docutils literal notranslate"><span class="pre">convert_to_*</span></code> functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">zv_ptr_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* get function argument */</span><span class="p">;</span>

<span class="n">convert_to_long_ex</span><span class="p">(</span><span class="n">zv_ptr_ptr</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_LVAL_PP</span><span class="p">(</span><span class="n">zv_ptr_ptr</span><span class="p">));</span>

<span class="cm">/* No need to dtor as function arguments are dtored automatically */</span>
</pre></div>
</div>
<p>But even this will not always be enough. Lets consider a very similar case where a value is fetched from an array:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">array_zv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* get array from somewhere */</span><span class="p">;</span>

<span class="cm">/* Fetch array index 42 into zv_dest (how this works is not relevant here) */</span>
<span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">zv_dest</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">zend_hash_index_find</span><span class="p">(</span><span class="n">Z_ARRVAL_P</span><span class="p">(</span><span class="n">array_zv</span><span class="p">),</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FAILURE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Error: Index not found */</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">convert_to_long_ex</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_LVAL_PP</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">));</span>

<span class="cm">/* No need to dtor because array values are dtored automatically */</span>
</pre></div>
</div>
<p>The use of <code class="docutils literal notranslate"><span class="pre">convert_to_long_ex()</span></code> in the above code will prevent modification of references to the value outside the
array, but it will still change the value inside the array itself. In some cases this is the correct behavior, but
typically you want to avoid modifying the array when fetching values from it.</p>
<p>In cases like these there is no way around copying the zval before converting it:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">zv_dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* get array value */</span><span class="p">;</span>
<span class="n">zval</span><span class="w"> </span><span class="n">tmp_zv</span><span class="p">;</span>

<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">zv_dest</span><span class="p">);</span>
<span class="n">zval_copy_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">);</span>

<span class="n">convert_to_long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_LVAL</span><span class="p">(</span><span class="n">tmp_zv</span><span class="p">));</span>

<span class="n">zval_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">);</span>
</pre></div>
</div>
<p>The last <code class="docutils literal notranslate"><span class="pre">zval_dtor()</span></code> call in the above code is not strictly necessary, because we know that <code class="docutils literal notranslate"><span class="pre">tmp_zv</span></code> will be
of type <code class="docutils literal notranslate"><span class="pre">IS_LONG</span></code>, which is a type that does not require destruction. For conversions to other types like strings or
arrays the dtor call is necessary though.</p>
<p>If the use of to-long or to-double conversions is common in your code, it can make sense to create helper functions which
perform casts without modifying any zval. A sample implementation for long casts:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="nf">zval_get_long</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">zv</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_NULL</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_BOOL</span><span class="p">:</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_LONG</span><span class="p">:</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_RESOURCE</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_DOUBLE</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">zend_dval_to_lval</span><span class="p">(</span><span class="n">Z_DVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">));</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_STRING</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">strtol</span><span class="p">(</span><span class="n">Z_STRVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">),</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_ARRAY</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">zend_hash_num_elements</span><span class="p">(</span><span class="n">Z_ARRVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">))</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">IS_OBJECT</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">zval</span><span class="w"> </span><span class="n">tmp_zv</span><span class="p">;</span>
<span class="w">            </span><span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">,</span><span class="w"> </span><span class="n">zv</span><span class="p">);</span>
<span class="w">            </span><span class="n">zval_copy_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">            </span><span class="n">convert_to_long_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">tmp_zv</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code will directly return the result of the cast without performing any zval copies (apart from the
<code class="docutils literal notranslate"><span class="pre">IS_OBJECT</span></code> case where the copy is unavoidable). By making use of the function the array value cast example becomes
much simpler:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">**</span><span class="n">zv_dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* get array value */</span><span class="p">;</span>
<span class="kt">long</span><span class="w"> </span><span class="n">lval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zval_get_long</span><span class="p">(</span><span class="o">*</span><span class="n">zv_dest</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lval</span><span class="p">);</span>
</pre></div>
</div>
<p>PHPs standard library already contains one function of this type, namely <code class="docutils literal notranslate"><span class="pre">zend_is_true()</span></code>. This function is
functionally equivalent to a bool cast from which the value is returned directly:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>

<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">zend_is_true</span><span class="p">(</span><span class="n">zv</span><span class="p">));</span><span class="w"> </span><span class="c1">// 0</span>
<span class="n">zval_dtor</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>

<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foobar&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">zend_is_true</span><span class="p">(</span><span class="n">zv</span><span class="p">));</span><span class="w"> </span><span class="c1">// 1</span>
<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="p">);</span>
</pre></div>
</div>
<p>Another function which avoids unnecessary copies during casting is <code class="docutils literal notranslate"><span class="pre">zend_make_printable_zval()</span></code>. This function
performs the same string cast as <code class="docutils literal notranslate"><span class="pre">convert_to_string()</span></code> but makes use of a different API. The typical usage is as
follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* get zval from somewhere */</span><span class="p">;</span>

<span class="n">zval</span><span class="w"> </span><span class="n">tmp_zval</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">tmp_zval_used</span><span class="p">;</span>
<span class="n">zend_make_printable_zval</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp_zval</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp_zval_used</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp_zval_used</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zv_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp_zval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PHPWRITE</span><span class="p">(</span><span class="n">Z_STRVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">),</span><span class="w"> </span><span class="n">Z_STRLEN_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp_zval_used</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zval_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zval</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second parameter to this function is a pointer to a temporary zval and the third parameter is a pointer to an
integer. If the function makes use of the temporary zval, the integer will be set to one, zero otherwise.</p>
<p>Based on <code class="docutils literal notranslate"><span class="pre">tmp_zval_used</span></code> you can then decide whether to use the original zval or the temporary copy. Very commonly
the temporary zval is simply assigned to the original zval using <code class="docutils literal notranslate"><span class="pre">zv_ptr</span> <span class="pre">=</span> <span class="pre">&amp;tmp_zval</span></code>. This allows you to always work
with <code class="docutils literal notranslate"><span class="pre">zv_ptr</span></code> rather than having conditionals everywhere to choose between the two.</p>
<p>Finally you need to dtor the temporary zval using <code class="docutils literal notranslate"><span class="pre">zval_dtor(&amp;tmp_zval)</span></code>, but only if it was actually used.</p>
<p>Another function that is related to casting is <code class="docutils literal notranslate"><span class="pre">is_numeric_string()</span></code>. This function checks whether a string is
“numeric” and extracts the value into either a long or a double:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="n">lval</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">dval</span><span class="p">;</span>

<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">is_numeric_string</span><span class="p">(</span><span class="n">Z_STRVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">),</span><span class="w"> </span><span class="n">Z_STRLEN_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lval</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dval</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_LONG</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* String is an integer those value was put into `lval` */</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_DOUBLE</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* String is a double those value was put into `dval` */</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="cm">/* String is not numeric */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last argument to this function is called <code class="docutils literal notranslate"><span class="pre">allow_errors</span></code>. Setting it to <code class="docutils literal notranslate"><span class="pre">0</span></code> will reject strings like
<code class="docutils literal notranslate"><span class="pre">&quot;123abc&quot;</span></code>, whereas setting it to <code class="docutils literal notranslate"><span class="pre">1</span></code> will silently allow them (with value <code class="docutils literal notranslate"><span class="pre">123</span></code>). A third value <code class="docutils literal notranslate"><span class="pre">-1</span></code> provides
an intermediate solution, which accepts the string, but throws a notice.</p>
<p>It is helpful to know that this function also accepts hexadecimal numbers in the <code class="docutils literal notranslate"><span class="pre">0xabc</span></code> format. In this it differs
from <code class="docutils literal notranslate"><span class="pre">convert_to_long()</span></code> and <code class="docutils literal notranslate"><span class="pre">convert_to_double()</span></code> which would cast <code class="docutils literal notranslate"><span class="pre">&quot;0xabc&quot;</span></code> to zero.</p>
<p><code class="docutils literal notranslate"><span class="pre">is_numeric_string()</span></code> is particularly useful in cases where you can work with both integer and floating point numbers,
but don’t want to incur the precision loss associated with using doubles for both cases. To help this use case, there
is an additional <code class="docutils literal notranslate"><span class="pre">convert_scalar_to_number()</span></code> function, which accepts a zval and converts non-array values to either
a long or a double (using <code class="docutils literal notranslate"><span class="pre">is_numeric_string()</span></code> for strings). This means that the converted zval will have type
<code class="docutils literal notranslate"><span class="pre">IS_LONG</span></code>, <code class="docutils literal notranslate"><span class="pre">IS_DOUBLE</span></code> or <code class="docutils literal notranslate"><span class="pre">IS_ARRAY</span></code>. The usage is the same as for the <code class="docutils literal notranslate"><span class="pre">convert_to_*()</span></code> functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3.141&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="n">convert_scalar_to_number</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_LONG</span><span class="p">:</span>
<span class="w">        </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Long: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_DOUBLE</span><span class="p">:</span>
<span class="w">        </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Double: %G</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_DVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/* Likely throw an error here */</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_ptr</span><span class="p">);</span>

<span class="cm">/* Double: 3.141 */</span>
</pre></div>
</div>
<p>Once again there also is a <code class="docutils literal notranslate"><span class="pre">convert_scalar_to_number_ex()</span></code> variant of this function, which accepts a <code class="docutils literal notranslate"><span class="pre">zval**</span></code> and
will separate it before the conversion.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../hashtables.html">Hashtables</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>