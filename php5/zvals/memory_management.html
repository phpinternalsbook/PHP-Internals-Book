<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Memory management &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Casts and operations" href="casts_and_operations.html" />
    <link rel="prev" title="Basic structure" href="basic_structure.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Memory management</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="basic_structure.html">Basic structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="casts_and_operations.html">Casts and operations</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="memory-management">
<h1>Memory management<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h1>
<p>The zval structure has two roles: The first, which was described in the previous section, is to store a value and its
type. The second, which will be covered in this section, is to efficiently manage those values in memory.</p>
<p>In the following we’ll have a look at the concepts of reference-counting and copy-on-write and find out how to make use
of them in extension code.</p>
<section id="value-and-reference-semantics">
<h2>Value- and reference-semantics<a class="headerlink" href="#value-and-reference-semantics" title="Link to this heading">¶</a></h2>
<p>In PHP all values always have value-semantics, unless you explicitly ask for a reference. This means that whenever
you pass a value to a function or assign one variable to another you’ll be working on two separate copies of the value.
Some examples to make sure that this is clear:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$a</span><span class="o">++</span><span class="p">;</span>

<span class="c1">// Only $a was incremented, $b stays as is:</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">);</span> <span class="c1">// int(2), int(1)</span>

<span class="k">function</span> <span class="nf">inc</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$n</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="nv">$c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">inc</span><span class="p">(</span><span class="nv">$c</span><span class="p">);</span>

<span class="c1">// The $c value outside the function and the $n inside the function are distinct</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$c</span><span class="p">);</span> <span class="c1">// int(1)</span>
</pre></div>
</div>
<p>While the above is rather obvious, it’s important to realize that this is a general rule that always holds. In
particular this also applies to objects:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$obj</span> <span class="o">=</span> <span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">];</span>

<span class="k">function</span> <span class="nf">fnByVal</span><span class="p">(</span><span class="nv">$val</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$val</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">fnByRef</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$ref</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$ref</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// The by-value function does not modify $obj, the by-reference function does:</span>

<span class="nx">fnByVal</span><span class="p">(</span><span class="nv">$obj</span><span class="p">);</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$obj</span><span class="p">);</span> <span class="c1">// stdClass(value =&gt; 1)</span>
<span class="nx">fnByRef</span><span class="p">(</span><span class="nv">$obj</span><span class="p">);</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$obj</span><span class="p">);</span> <span class="c1">// int(100)</span>
</pre></div>
</div>
<p>People often say that objects are automatically passed by-reference since PHP 5, but as the above example shows this is
not true: A by-value function cannot modify the value of the variable that was passed to it, only a by-reference
function can do that.</p>
<p>It is true however that objects exhibit a “reference-like” behavior: While you can not assign a completely different
value, you can still change the properties of the object. This is a result of the fact than an object value is just an
ID that can be used to look up the “actual content” of the object. Value-semantics only prevent you from changing this
ID to a different object or switching the type altogether, but they do not prevent you to change the “actual content” of
the object.</p>
<p>The same applies to resources, because they also only store an ID which can be used to look up their actual value.
So again the value-semantics prevent you from changing the resource ID or the type of the zval, but they do not
prevent you from changing the content of the resource (like advancing the position in a file).</p>
</section>
<section id="reference-counting-and-copy-on-write">
<h2>Reference-counting and copy-on-write<a class="headerlink" href="#reference-counting-and-copy-on-write" title="Link to this heading">¶</a></h2>
<p>If you think about the above for a bit, you’ll come to the conclusion that PHP must be doing an awful lot of copying.
Every time you pass something to a function the value needs to be copied. This may not be particularly problematic for
an integer or a double, but imagine passing an array with ten million elements to a function. Copying millions of
elements on every call would be prohibitively slow.</p>
<p>To avoid doing so, PHP employs the copy-on-write paradigm: A zval can be shared by multiple variables/functions/etc as
long as it’s only read from and not modified. If one of the holders wants to modify it, the zval needs to be copied
before applying any changes.</p>
<p>If one zval can be used in multiple places, PHP needs some way to find out when the zval is no longer used by anyone,
in order to destroy (and free) it. PHP accomplishes this simply by keeping track of how often the zval is referenced.
Note that “referenced” here has nothing to do with PHP references (as in <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) and just means that something (a
variable, function, etc) makes use of the zval. The number of references is called the <em>refcount</em> and stored in the
<code class="docutils literal notranslate"><span class="pre">refcount__gc</span></code> member of the zval.</p>
<p>To understand how this works lets consider an example:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// $a =           zval_1(value=1, refcount=1)</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>   <span class="c1">// $a = $b =      zval_1(value=1, refcount=2)</span>
<span class="nv">$c</span> <span class="o">=</span> <span class="nv">$b</span><span class="p">;</span>   <span class="c1">// $a = $b = $c = zval_1(value=1, refcount=3)</span>

<span class="nv">$a</span><span class="o">++</span><span class="p">;</span>      <span class="c1">// $b = $c = zval_1(value=1, refcount=2)</span>
           <span class="c1">// $a =      zval_2(value=2, refcount=1)</span>

<span class="nb">unset</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span> <span class="c1">// $c = zval_1(value=1, refcount=1)</span>
           <span class="c1">// $a = zval_2(value=2, refcount=1)</span>

<span class="nb">unset</span><span class="p">(</span><span class="nv">$c</span><span class="p">);</span> <span class="c1">// zval_1 is destroyed, because refcount=0</span>
           <span class="c1">// $a = zval_2(value=2, refcount=1)</span>
</pre></div>
</div>
<p>The behavior is very straightforward: When a reference is added, increment the refcount, if a reference is removed,
decrement it. If the refcount reaches 0, the zval is destroyed.</p>
<p>One case where this method does not work is the case of a circular reference:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$a</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// $a = zval_1(value=[], refcount=1)</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// $b = zval_2(value=[], refcount=1)</span>

<span class="nv">$a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$b</span><span class="p">;</span> <span class="c1">// $a = zval_1(value=[0 =&gt; zval_2], refcount=1)</span>
            <span class="c1">// $b = zval_2(value=[], refcount=2)</span>
            <span class="c1">// The refcount of zval_2 is incremented because it</span>
            <span class="c1">// is used in the array of zval_1</span>

<span class="nv">$b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1">// $a = zval_1(value=[0 =&gt; zval_2], refcount=2)</span>
            <span class="c1">// $b = zval_2(value=[0 =&gt; zval_1], refcount=2)</span>
            <span class="c1">// The refcount of zval_1 is incremented because it</span>
            <span class="c1">// is used in the array of zval_2</span>

<span class="nb">unset</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>  <span class="c1">//      zval_1(value=[0 =&gt; zval_2], refcount=1)</span>
            <span class="c1">// $b = zval_2(value=[0 =&gt; zval_1], refcount=2)</span>
            <span class="c1">// The refcount of zval_1 is decremented, but the zval has</span>
            <span class="c1">// to stay alive because it&#39;s still referenced by zval_2</span>

<span class="nb">unset</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span>  <span class="c1">//      zval_1(value=[0 =&gt; zval_2], refcount=1)</span>
            <span class="c1">//      zval_2(value=[0 =&gt; zval_1], refcount=1)</span>
            <span class="c1">// The refcount of zval_2 is decremented, but the zval has</span>
            <span class="c1">// to stay alive because it&#39;s still referenced by zval_1</span>
</pre></div>
</div>
<p>After the above code has run, we have reached a situation where we have two zvals that are not reachable by any variable,
but are still kept alive because they reference each other. This is a classical example of where reference-counting
fails.</p>
<p>To address this issue PHP has a second garbage collection mechanism: a cycle collector. We can safely ignore it for now,
because the cycle collector (unlike the reference-counting mechanism) is mostly transparent to extension authors. If you
wish to learn more on this topic, the PHP manual contains a short <a class="reference external" href="http://php.net/manual/en/features.gc.collecting-cycles.php">description of the algorithm</a>.</p>
<p>Another case that has to be considered are “actual” PHP references (as in <code class="docutils literal notranslate"><span class="pre">&amp;$var</span></code>, not the internal “references” we’ve
been talking about above). To denote that a zval uses a PHP reference a boolean is_ref flag is used, which is stored in
the <code class="docutils literal notranslate"><span class="pre">is_ref__gc</span></code> member of the zval structure.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">is_ref=1</span></code> flag on a zval signals that the zval should <strong>not</strong> be copied before modification. Instead code should
directly modify the value:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// $a =      zval_1(value=1, refcount=1, is_ref=0)</span>
<span class="nv">$b</span> <span class="o">=&amp;</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1">// $a = $b = zval_1(value=1, refcount=2, is_ref=1)</span>

<span class="nv">$b</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// $a = $b = zval_1(value=2, refcount=2, is_ref=1)</span>
          <span class="c1">// Due to the is_ref=1 PHP directly changes the zval</span>
          <span class="c1">// rather than making a copy</span>
</pre></div>
</div>
<p>In the above example the zval of <code class="docutils literal notranslate"><span class="pre">$a</span></code> has refcount=1 before the reference is created. Now consider a very similar
example where the original refcount is larger than one:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// $a =           zval_1(value=1, refcount=1, is_ref=0)</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>  <span class="c1">// $a = $b =      zval_1(value=1, refcount=2, is_ref=0)</span>
<span class="nv">$c</span> <span class="o">=</span> <span class="nv">$b</span>   <span class="c1">// $a = $b = $c = zval_1(value=1, refcount=3, is_ref=0)</span>

<span class="nv">$d</span> <span class="o">=&amp;</span> <span class="nv">$c</span><span class="p">;</span> <span class="c1">// $a = $b = zval_1(value=1, refcount=2, is_ref=0)</span>
          <span class="c1">// $c = $d = zval_2(value=1, refcount=2, is_ref=1)</span>
          <span class="c1">// $d is a reference of $c, but *not* of $a and $b, so</span>
          <span class="c1">// the zval needs to be copied here. Now we have the</span>
          <span class="c1">// same zval once with is_ref=0 and once with is_ref=1.</span>

<span class="nv">$d</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// $a = $b = zval_1(value=1, refcount=2, is_ref=0)</span>
          <span class="c1">// $c = $d = zval_2(value=2, refcount=2, is_ref=1)</span>
          <span class="c1">// Because there are two separate zvals $d++ does</span>
          <span class="c1">// not modify $a and $b (as expected).</span>
</pre></div>
</div>
<p>As you can see <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>-referencing a zval with is_ref=0 and refcount&gt;1 requires a copy. Similarly trying to use a zval
with is_ref=1 and refcount&gt;1 in a by-value context will require a copy. For this reason making use of PHP references
usually slows code down: Nearly all functions in PHP use by-value passing semantics, so they will likely trigger a copy
when an is_ref=1 zval is passed to them.</p>
</section>
<section id="allocating-and-initializing-zvals">
<h2>Allocating and initializing zvals<a class="headerlink" href="#allocating-and-initializing-zvals" title="Link to this heading">¶</a></h2>
<p>Now that you are familiar with the general concepts underlying zval memory management, we can move on to their practical
implementation. Lets start with zval allocation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>This code-snippets allocates a zval, but does not initialize its members. There is a variant of this macro used to
allocate persistent zvals, which are not destroyed at the end of the request:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">ALLOC_PERMANENT_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>The difference between the two macros is that the former makes use of <code class="docutils literal notranslate"><span class="pre">emalloc()</span></code> whereas the latter uses
<code class="docutils literal notranslate"><span class="pre">malloc()</span></code>. It’s important to know though that trying to directly allocate zvals will not work:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* This code is WRONG */</span>
<span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">emalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">zval</span><span class="p">));</span>
</pre></div>
</div>
<p>The reason is that the cycle collector needs to store some additional information in the zval, so the structure that
needs to be allocated is actually not a <code class="docutils literal notranslate"><span class="pre">zval</span></code> but a <code class="docutils literal notranslate"><span class="pre">zval_gc_info</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_zval_gc_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zval</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">gc_root_buffer</span><span class="w">       </span><span class="o">*</span><span class="n">buffered</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">_zval_gc_info</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">zval_gc_info</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ALLOC_*</span></code> macros will allocate a <code class="docutils literal notranslate"><span class="pre">zval_gc_info</span></code> and initialize its additional member, but afterwards the value
can be transparently used as a <code class="docutils literal notranslate"><span class="pre">zval</span></code> (because the structure includes a <code class="docutils literal notranslate"><span class="pre">zval</span></code> as its first member).</p>
<p>After the zval has been allocated, it needs to be initialized. There are two macros to do this. The first one is
<code class="docutils literal notranslate"><span class="pre">INIT_PZVAL</span></code>, which will set refcount=1 and is_ref=0 but leave the value uninitialized:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">INIT_PZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="cm">/* zv_ptr has garbage type+value here */</span>
</pre></div>
</div>
<p>The second macro is <code class="docutils literal notranslate"><span class="pre">INIT_ZVAL</span></code> which will also set refcount=1 and is_ref=0, but will additionally set the type to
<code class="docutils literal notranslate"><span class="pre">IS_NULL</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">INIT_ZVAL</span><span class="p">(</span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="cm">/* zv_ptr has type=IS_NULL here */</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">INIT_PZVAL()</span></code> accepts a <code class="docutils literal notranslate"><span class="pre">zval*</span></code> (thus the <code class="docutils literal notranslate"><span class="pre">P</span></code> in its name) whereas <code class="docutils literal notranslate"><span class="pre">INIT_ZVAL()</span></code> takes a <code class="docutils literal notranslate"><span class="pre">zval</span></code>. When passing
a <code class="docutils literal notranslate"><span class="pre">zval*</span></code> to the latter macro it needs to be dereferenced first.</p>
<p>Because it is very common to both allocate and initialize a zval in one go, there are two macros which combine both
steps:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="cm">/* zv_ptr has garbage type+value here */</span>

<span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">ALLOC_INIT_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="cm">/* zv_ptr has type=IS_NULL here */</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MAKE_STD_ZVAL()</span></code> combines allocation with <code class="docutils literal notranslate"><span class="pre">INIT_PZVAL()</span></code>, whereas <code class="docutils literal notranslate"><span class="pre">ALLOC_INIT_ZVAL()</span></code> combines it with
<code class="docutils literal notranslate"><span class="pre">INIT_ZVAL()</span></code>.</p>
</section>
<section id="managing-the-refcount-and-zval-destruction">
<h2>Managing the refcount and zval destruction<a class="headerlink" href="#managing-the-refcount-and-zval-destruction" title="Link to this heading">¶</a></h2>
<p>Once you have an allocated and initialized zval you can make use of the reference-counting mechanism introduced earlier.
To manage the refcount PHP provides several macros:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Z_REFCOUNT_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">)</span><span class="w">      </span><span class="cm">/* Get refcount */</span>
<span class="n">Z_ADDREF_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">)</span><span class="w">        </span><span class="cm">/* Increment refcount */</span>
<span class="n">Z_DELREF_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">)</span><span class="w">        </span><span class="cm">/* Decrement refcount */</span>
<span class="n">Z_SET_REFCOUNT</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="cm">/* Set refcount to some particular value (here 1) */</span>
</pre></div>
</div>
<p>Just like the other <code class="docutils literal notranslate"><span class="pre">Z_</span></code> macros these are available in variants without a suffix, with a <code class="docutils literal notranslate"><span class="pre">_P</span></code> suffix and with a
<code class="docutils literal notranslate"><span class="pre">_PP</span></code> suffix, which accept a <code class="docutils literal notranslate"><span class="pre">zval</span></code>, a <code class="docutils literal notranslate"><span class="pre">zval*</span></code> and a <code class="docutils literal notranslate"><span class="pre">zval**</span></code> respectively.</p>
<p>The macro you will most commonly use is <code class="docutils literal notranslate"><span class="pre">Z_ADDREF_P()</span></code>. A small example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">ZVAL_LONG</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>

<span class="n">add_index_zval</span><span class="p">(</span><span class="n">some_array</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">add_assoc_zval</span><span class="p">(</span><span class="n">some_array</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;num&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">Z_ADDREF_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>The code inserts the integer 42 into an array at the index <code class="docutils literal notranslate"><span class="pre">0</span></code> and the key <code class="docutils literal notranslate"><span class="pre">&quot;num&quot;</span></code>, so the zval will be used in two
places. After the allocation and initialization done by <code class="docutils literal notranslate"><span class="pre">MAKE_STD_ZVAL()</span></code> the zval starts off with a refcount of 1.
To use the same zval in two places it needs a refcount of 2, thus it has to be incremented using <code class="docutils literal notranslate"><span class="pre">Z_ADDREF_P()</span></code>.</p>
<p>The complement macro <code class="docutils literal notranslate"><span class="pre">Z_DELREF_P()</span></code> on the other hand is used rather rarely: Usually just decrementing the refcount
is not enough, because you have to check for the <code class="docutils literal notranslate"><span class="pre">refcount==0</span></code> case where the zval needs to be destroyed and freed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Z_DELREF_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_REFCOUNT_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zval_dtor</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="n">efree</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">zval_dtor()</span></code> macro takes a <code class="docutils literal notranslate"><span class="pre">zval*</span></code> and destroys its value: If it is a string, the string will be freed, if it
is an array, the HashTable will be destroyed and freed, if it is an object or resource, the refcount of their actual
values is decremented (which again might lead to them being destroyed and freed).</p>
<p>Instead of writing the above code for checking the refcount yourself, you should use a second macro called
<code class="docutils literal notranslate"><span class="pre">zval_ptr_dtor()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>This macro takes a <code class="docutils literal notranslate"><span class="pre">zval**</span></code> (for historical reasons, it could take a <code class="docutils literal notranslate"><span class="pre">zval*</span></code> just as well), decrements its refcount
and checks whether the zval needs to be destroyed and freed. But unlike our manually written code above, it also
includes support for the collection of circles. Here is the relevant part of its implementation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">i_zval_ptr_dtor</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zval_ptr</span><span class="w"> </span><span class="n">ZEND_FILE_LINE_DC</span><span class="w"> </span><span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Z_DELREF_P</span><span class="p">(</span><span class="n">zval_ptr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ZEND_ASSERT</span><span class="p">(</span><span class="n">zval_ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">EG</span><span class="p">(</span><span class="n">uninitialized_zval</span><span class="p">));</span>
<span class="w">        </span><span class="n">GC_REMOVE_ZVAL_FROM_BUFFER</span><span class="p">(</span><span class="n">zval_ptr</span><span class="p">);</span>
<span class="w">        </span><span class="n">zval_dtor</span><span class="p">(</span><span class="n">zval_ptr</span><span class="p">);</span>
<span class="w">        </span><span class="n">efree_rel</span><span class="p">(</span><span class="n">zval_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_REFCOUNT_P</span><span class="p">(</span><span class="n">zval_ptr</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Z_UNSET_ISREF_P</span><span class="p">(</span><span class="n">zval_ptr</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">GC_ZVAL_CHECK_POSSIBLE_ROOT</span><span class="p">(</span><span class="n">zval_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Z_DELREF_P()</span></code> returns the new refcount after it was decremented, so writing <code class="docutils literal notranslate"><span class="pre">!Z_DELREF_P(zval_ptr)</span></code> is the same
as writing <code class="docutils literal notranslate"><span class="pre">Z_DELREF_P(zval_ptr)</span></code> followed by a check for <code class="docutils literal notranslate"><span class="pre">Z_REFCOUNT_P(zval_ptr)</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>Apart from doing the expected <code class="docutils literal notranslate"><span class="pre">zval_dtor()</span></code> and <code class="docutils literal notranslate"><span class="pre">efree()</span></code> operations the code also calls two <code class="docutils literal notranslate"><span class="pre">GC_*</span></code> macros
handling cycle collection and asserts that <code class="docutils literal notranslate"><span class="pre">&amp;EG(uninitialized_zval)</span></code> is never freed (this is a magic zval used by the
engine).</p>
<p>Furthermore the code also sets <code class="docutils literal notranslate"><span class="pre">is_ref=0</span></code> if there is only one reference left to the zval. Leaving <code class="docutils literal notranslate"><span class="pre">is_ref=1</span></code> in
this case wouldn’t really make sense because the concept of a <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> PHP reference only becomes meaningful when two or
more holders share a zval.</p>
<p>Some hints on the usage of these macros: You should not use <code class="docutils literal notranslate"><span class="pre">Z_DELREF_P()</span></code> at all (it’s only applicable in situations
where you can guarantee that the zval neither needs to be destroyed nor is a possible root for a circle). Instead you
should use <code class="docutils literal notranslate"><span class="pre">zval_ptr_dtor()</span></code> whenever you want to decrement the refcount. The <code class="docutils literal notranslate"><span class="pre">zval_dtor()</span></code> macro is typically used
with temporary, stack-allocated zvals:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="n">zv</span><span class="p">;</span>
<span class="n">INIT_ZVAL</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>

<span class="cm">/* Do something with zv here */</span>

<span class="n">zval_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="p">);</span>
</pre></div>
</div>
<p>A temporary zval allocated on the stack cannot be shared because it is freed at the end of the block, as such it cannot
make use of refcounting and can be destroyed indiscriminately using <code class="docutils literal notranslate"><span class="pre">zval_dtor()</span></code>.</p>
</section>
<section id="copying-zvals">
<h2>Copying zvals<a class="headerlink" href="#copying-zvals" title="Link to this heading">¶</a></h2>
<p>While the copy-on-write mechanism can save a lot of zval copies, they do have to happen at some point, e.g. if you
want to change the value of the zval or transfer it to another storage location.</p>
<p>PHP provides a large number of copying macros for various use cases, the simplest one being <code class="docutils literal notranslate"><span class="pre">ZVAL_COPY_VALUE()</span></code>,
which just copies the <code class="docutils literal notranslate"><span class="pre">value</span></code> and <code class="docutils literal notranslate"><span class="pre">type</span></code> members of a zval:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_src</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_src</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv_src</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_dest</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>
<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">);</span>
</pre></div>
</div>
<p>At this point <code class="docutils literal notranslate"><span class="pre">zv_dest</span></code> will have the same type and value as <code class="docutils literal notranslate"><span class="pre">zv_src</span></code>. Note that “same value” here means that both
zvals are using the same string value (<code class="docutils literal notranslate"><span class="pre">char*</span></code>), i.e. if the <code class="docutils literal notranslate"><span class="pre">zv_src</span></code> zval is destroyed the string value will be
freed and <code class="docutils literal notranslate"><span class="pre">zv_dest</span></code> will be left with a dangling pointer to the freed string. To avoid this the zval copy constructor
<code class="docutils literal notranslate"><span class="pre">zval_copy_ctor()</span></code> needs to be invoked:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_dest</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>
<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">);</span>
<span class="n">zval_copy_ctor</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">zval_copy_ctor()</span></code> will do a fully copy of the zval value, i.e. if it is a string the <code class="docutils literal notranslate"><span class="pre">char*</span></code> will be copied, if it
is an array the <code class="docutils literal notranslate"><span class="pre">HashTable*</span></code> is copied and if it is an object or resource their internal reference counts are
incremented.</p>
<p>The only thing that is missing now is the initialization of the refcount and the is_ref flag. This could be done using
the <code class="docutils literal notranslate"><span class="pre">INIT_PZVAL()</span></code> macro or by making use of <code class="docutils literal notranslate"><span class="pre">MAKE_STD_ZVAL()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">ALLOC_ZVAL()</span></code>. Another alternative is
to use <code class="docutils literal notranslate"><span class="pre">INIT_PZVAL_COPY()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">ZVAL_COPY_VALUE()</span></code> which combines doing a copy with refcount/is_ref
initialization:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_dest</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>
<span class="n">INIT_PZVAL_COPY</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">);</span>
<span class="n">zval_copy_ctor</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>
</pre></div>
</div>
<p>As the combination of <code class="docutils literal notranslate"><span class="pre">INIT_PZVAL_COPY()</span></code> and <code class="docutils literal notranslate"><span class="pre">zval_copy_ctor()</span></code> is very common, both are combined in the
<code class="docutils literal notranslate"><span class="pre">MAKE_COPY_ZVAL()</span></code> macro:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv_dest</span><span class="p">;</span>
<span class="n">ALLOC_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>
<span class="n">MAKE_COPY_ZVAL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_src</span><span class="p">,</span><span class="w"> </span><span class="n">zv_dest</span><span class="p">);</span>
</pre></div>
</div>
<p>This macro has a bit of a tricky signature, because it swaps the argument order (the destination is now the second
argument rather than the first) and also requires the source to be a <code class="docutils literal notranslate"><span class="pre">zval**</span></code>. Once again this is just a historic
artifact and doesn’t make any technical sense whatsoever.</p>
<p>Apart from these basic copying macros there are several more complicated ones. The most important is <code class="docutils literal notranslate"><span class="pre">ZVAL_ZVAL</span></code>,
which is especially common when returning zvals from a function. It has the following signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ZVAL_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">,</span><span class="w"> </span><span class="n">copy</span><span class="p">,</span><span class="w"> </span><span class="n">dtor</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">copy</span></code> parameter specifies whether <code class="docutils literal notranslate"><span class="pre">zval_copy_ctor()</span></code> should be called on the destination zval and <code class="docutils literal notranslate"><span class="pre">dtor</span></code>
determines whether <code class="docutils literal notranslate"><span class="pre">zval_ptr_dtor()</span></code> is called on the source zval. Let’s go through all four possible combinations
of those values and analyze the behavior. The simplest case is setting both copy and dtor to zero:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ZVAL_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="cm">/* equivalent to: */</span>
<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case <code class="docutils literal notranslate"><span class="pre">ZVAL_ZVAL()</span></code> becomes a simple <code class="docutils literal notranslate"><span class="pre">ZVAL_COPY_VALUE()</span></code> call. As such using this macro with 0,0 arguments
doesn’t really make sense. A more useful variant is copy=1, dtor=0:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ZVAL_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="cm">/* equivalent to: */</span>
<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">);</span>
<span class="n">zval_copy_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_src</span><span class="p">);</span>
</pre></div>
</div>
<p>This is basically a normal zval copy analog to <code class="docutils literal notranslate"><span class="pre">MAKE_COPY_ZVAL()</span></code>, only without the <code class="docutils literal notranslate"><span class="pre">INIT_PZVAL()</span></code> step. This is
useful when copying into zvals that are already initialized (e.g. <code class="docutils literal notranslate"><span class="pre">return_value</span></code>). Additionally setting dtor=1 only
adds a <code class="docutils literal notranslate"><span class="pre">zval_ptr_dtor()</span></code> call:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ZVAL_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="cm">/* equivalent to: */</span>
<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">);</span>
<span class="n">zval_copy_ctor</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>
<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_src</span><span class="p">);</span>
</pre></div>
</div>
<p>The most interesting case is the copy=0, dtor=1 combination:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ZVAL_ZVAL</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="cm">/* equivalent to: */</span>
<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">,</span><span class="w"> </span><span class="n">zv_src</span><span class="p">);</span>
<span class="n">ZVAL_NULL</span><span class="p">(</span><span class="n">zv_src</span><span class="p">);</span>
<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_src</span><span class="p">);</span>
</pre></div>
</div>
<p>This constitutes a zval “move”, where the value from <code class="docutils literal notranslate"><span class="pre">zv_src</span></code> is moved into <code class="docutils literal notranslate"><span class="pre">zv_dest</span></code> without having to invoke the
copy constructor. This is something that should only be done if <code class="docutils literal notranslate"><span class="pre">zv_src</span></code> has refcount=1, in which case the zval will
be destroyed by the <code class="docutils literal notranslate"><span class="pre">zval_ptr_dtor()</span></code> call. If it has a higher refcount the zval will stay alive with a NULL value.</p>
<p>There are two further macros for copying zvals, namely <code class="docutils literal notranslate"><span class="pre">COPY_PZVAL_TO_ZVAL()</span></code> and <code class="docutils literal notranslate"><span class="pre">REPLACE_ZVAL_VALUE()</span></code>. Both are
used rather rarely and will not be discussed here.</p>
</section>
<section id="separating-zvals">
<h2>Separating zvals<a class="headerlink" href="#separating-zvals" title="Link to this heading">¶</a></h2>
<p>The macros described above are mainly used when you want to copy a zval to another storage location. A typical example
is copying a value into the <code class="docutils literal notranslate"><span class="pre">return_value</span></code> zval. There is a second set of macros for “zval separation”, which
are used in the context of copy-on-write. Their functionality is best understood by looking at the source code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SEPARATE_ZVAL(ppzv)                     \</span>
<span class="cp">    do {                                        \</span>
<span class="cp">        if (Z_REFCOUNT_PP((ppzv)) &gt; 1) {        \</span>
<span class="cp">            zval *new_zv;                       \</span>
<span class="cp">            Z_DELREF_PP(ppzv);                  \</span>
<span class="cp">            ALLOC_ZVAL(new_zv);                 \</span>
<span class="cp">            INIT_PZVAL_COPY(new_zv, *(ppzv));   \</span>
<span class="cp">            *(ppzv) = new_zv;                   \</span>
<span class="cp">            zval_copy_ctor(new_zv);             \</span>
<span class="cp">        }                                       \</span>
<span class="cp">    } while (0)</span>
</pre></div>
</div>
<p>If the refcount is one, <code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL()</span></code> won’t do anything. If the refcount is larger, it will remove one ref from the
old zval, copy it to a new zval and assign that new zval to <code class="docutils literal notranslate"><span class="pre">*ppzv</span></code>. Note that the macro accepts a <code class="docutils literal notranslate"><span class="pre">zval**</span></code> and
will modify which <code class="docutils literal notranslate"><span class="pre">zval*</span></code> it points to.</p>
<p>How is this used practically? Imagine you want to modify an array offset like <code class="docutils literal notranslate"><span class="pre">$array[42]</span></code>. To do so, you first fetch
the <code class="docutils literal notranslate"><span class="pre">zval**</span></code> pointer to the stored <code class="docutils literal notranslate"><span class="pre">zval*</span></code> value. Due to the reference-counting you can’t directly modify it (as
it could be shared with other places), it needs to be separated first. The separation will either leave the old zval if
the refcount is one or it will perform a copy. In the latter case the new zval is assigned to <code class="docutils literal notranslate"><span class="pre">*ppzv</span></code>, which in this
case is the storage location in the array.</p>
<p>Doing a simple copy with <code class="docutils literal notranslate"><span class="pre">MAKE_COPY_ZVAL()</span></code> wouldn’t be sufficient here because the copied zval would not actually be
the zval stored in the array.</p>
<p>Directly using <code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL()</span></code> before performing a zval modification doesn’t yet account for the case where the zval
has is_ref=1, in which case the separation should not occur. To handle this case lets first look at the macros PHP
provides to handle the is_ref flag:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Z_ISREF_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">)</span><span class="w">           </span><span class="cm">/* Get if zval is reference */</span>

<span class="n">Z_SET_ISREF_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">)</span><span class="w">       </span><span class="cm">/* Set is_ref=1 */</span>
<span class="n">Z_UNSET_ISREF_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">)</span><span class="w">     </span><span class="cm">/* Set is_ref=0 */</span>

<span class="n">Z_SET_ISREF_TO_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="cm">/* Same as Z_SET_ISREF_P(zv_ptr) */</span>
<span class="n">Z_SET_ISREF_TO_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="cm">/* Same as Z_UNSET_ISREF_P(zv_ptr) */</span>
</pre></div>
</div>
<p>Once again the macros are available in variants without suffix, <code class="docutils literal notranslate"><span class="pre">_P</span></code> suffix and <code class="docutils literal notranslate"><span class="pre">_PP</span></code> suffix, accepting a <code class="docutils literal notranslate"><span class="pre">zval</span></code>,
<code class="docutils literal notranslate"><span class="pre">zval*</span></code> or <code class="docutils literal notranslate"><span class="pre">zval**</span></code> respectively. Furthermore there is an older <code class="docutils literal notranslate"><span class="pre">PZVAL_IS_REF()</span></code> macro which is synonymous with
<code class="docutils literal notranslate"><span class="pre">Z_ISREF_P()</span></code>.</p>
<p>Using these PHP provides two more variants of <code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SEPARATE_ZVAL_IF_NOT_REF(ppzv)      \</span>
<span class="cp">    if (!PZVAL_IS_REF(*ppzv)) {             \</span>
<span class="cp">        SEPARATE_ZVAL(ppzv);                \</span>
<span class="cp">    }</span>

<span class="cp">#define SEPARATE_ZVAL_TO_MAKE_IS_REF(ppzv)  \</span>
<span class="cp">    if (!PZVAL_IS_REF(*ppzv)) {             \</span>
<span class="cp">        SEPARATE_ZVAL(ppzv);                \</span>
<span class="cp">        Z_SET_ISREF_PP((ppzv));             \</span>
<span class="cp">    }</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL_IF_NOT_REF()</span></code> is the macro you’d usually use when modifying a zval according to copy-on-write.
<code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL_TO_MAKE_IS_REF()</span></code> is used when you want to turn a zval into a reference (e.g. for a by-reference
assignment or by-reference argument pass.) The latter is mainly used by the engine and only rarely in extension code.</p>
<p>There is another macro in the <code class="docutils literal notranslate"><span class="pre">SEPARATE</span></code> family, which works a bit differently from the other ones:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SEPARATE_ARG_IF_REF(varptr) \</span>
<span class="cp">    if (PZVAL_IS_REF(varptr)) { \</span>
<span class="cp">        zval *original_var = varptr; \</span>
<span class="cp">        ALLOC_ZVAL(varptr); \</span>
<span class="cp">        INIT_PZVAL_COPY(varptr, original_var); \</span>
<span class="cp">        zval_copy_ctor(varptr); \</span>
<span class="cp">    } else { \</span>
<span class="cp">        Z_ADDREF_P(varptr); \</span>
<span class="cp">    }</span>
</pre></div>
</div>
<p>The first difference is that this macro takes a <code class="docutils literal notranslate"><span class="pre">zval*</span></code> rather than a <code class="docutils literal notranslate"><span class="pre">zval**</span></code>. As such it will not be able to
modify the <code class="docutils literal notranslate"><span class="pre">zval*</span></code> it separates. Furthermore this macro already increments the refcount for you, whereas the
<code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL</span></code> macros do not.</p>
<p>Apart from this it basically complements <code class="docutils literal notranslate"><span class="pre">SEPARATE_ZVAL_IF_NO_REF()</span></code>: This time the separation happens when the
zval <strong>is</strong> a reference. It’s mainly used to make sure that an argument passed to a function is a value, not a
reference.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="basic_structure.html">Basic structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="casts_and_operations.html">Casts and operations</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>