<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Casts and operations &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Internal types" href="../internal_types.html" />
    <link rel="prev" title="References" href="references.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Casts and operations</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="references.html">References</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../internal_types.html">Internal types</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="casts-and-operations">
<h1>Casts and operations<a class="headerlink" href="#casts-and-operations" title="Link to this heading">¶</a></h1>
<section id="casts">
<h2>Casts<a class="headerlink" href="#casts" title="Link to this heading">¶</a></h2>
<p>In many situations, you expect to receive a zval of a specific type. In this case, you could strictly check for the
desired type:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IS_STRING</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zend_type_error</span><span class="p">(</span><span class="s">&quot;Expected string&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, you can perform a cast to the desired type. There are two ways in which casts can be performed: The first
is to actually change the type of the zval using one of the <code class="docutils literal notranslate"><span class="pre">convert_to_*</span></code> functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">convert_to_string</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="c1">// Z_TYPE_P(val) == IS_STRING is guaranteed here.</span>
</pre></div>
</div>
<p>Similar functions exist for all the other types that have a meaningful type cast:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_null</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_boolean</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_long</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_double</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_string</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_array</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">convert_to_object</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>In addition, the <code class="docutils literal notranslate"><span class="pre">convert_scalar_to_number()</span></code> function can be used to convert the zval into either an integer or a
float, with the caveat that arrays stay as arrays:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">convert_scalar_to_number</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_LONG</span><span class="p">:</span>
<span class="w">        </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Long: &quot;</span><span class="w"> </span><span class="n">ZEND_LONG_FMT</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_DOUBLE</span><span class="p">:</span>
<span class="w">        </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Long: %H</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Z_DVAL_P</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">IS_ARRAY</span><span class="p">:</span>
<span class="w">        </span><span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Array</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="n">ZEND_EMPTY_SWITCH_DEFAULT_CASE</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because <code class="docutils literal notranslate"><span class="pre">convert_to_*</span></code> modifies zvals in-place, care is needed to maintain copy-on-write semantics. A common mistake
is to write code like the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">;</span>
<span class="n">ZEND_HASH_FOREACH_VAL</span><span class="p">(</span><span class="n">Z_ARRVAL_P</span><span class="p">(</span><span class="n">array</span><span class="p">),</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">convert_to_string</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Use val as string.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we want to iterate over an array and treat all elements as strings. However, as <code class="docutils literal notranslate"><span class="pre">convert_to_string()</span></code> operates
in-place, this means that the array actually gets modified. As such, this code is only legal if you own the array
uniquely. Otherwise, it would be necessary to perform a separation first:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">;</span>
<span class="n">SEPARATE_ARRAY</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
<span class="n">ZEND_HASH_FOREACH_VAL</span><span class="p">(</span><span class="n">Z_ARRVAL_P</span><span class="p">(</span><span class="n">array</span><span class="p">),</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">convert_to_string</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Use val as string.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second set of cast APIs avoids this issue by returning the converted value instead of changing the type of the zval
itself. In the cases where it can be used, this is usually more convenient, more efficient and safer (with regard to
copy-on-write). When converting to booleans, integers and floats, we simply receive a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">zend_long</span></code>, or
<code class="docutils literal notranslate"><span class="pre">double</span></code> result and are done:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_is_true</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="n">zend_long</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zval_get_long</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zval_get_double</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</pre></div>
</div>
<p>For strings, we receive a <code class="docutils literal notranslate"><span class="pre">zend_string</span> <span class="pre">*</span></code> result, which we must release afterwards. If the value is already a string,
this will simply increment the refcount. If it’s not a string, it will either return an existing interned string, or
allocate a new one:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zval_get_string</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="c1">// Do something with str.</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>For this kind of temporary usage, where we don’t retain a long-term reference to <code class="docutils literal notranslate"><span class="pre">str</span></code>, an additional optimized API
exists:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">tmp_str</span><span class="p">;</span>
<span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zval_get_tmp_string</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp_str</span><span class="p">);</span>
<span class="c1">// Do something with str.</span>
<span class="n">zend_tmp_string_release</span><span class="p">(</span><span class="n">tmp_str</span><span class="p">);</span>
</pre></div>
</div>
<p>This API works the same way as <code class="docutils literal notranslate"><span class="pre">zval_get_string()</span></code>, but avoids a refcount increment and decrement for the common
case where the value is already a string.</p>
<p>When it comes to conversions to strings in particular, there is one additional issue to consider: <code class="docutils literal notranslate"><span class="pre">__toString()</span></code>
methods can throw (actually, conversions to int and float can throw as well, but this issue is usually ignored). This
can be handled by checking <code class="docutils literal notranslate"><span class="pre">EG(exception)</span></code> after a string conversion:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zval_get_string</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EG</span><span class="p">(</span><span class="n">exception</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// zend_string_release(str) is safe, but not necessary here.</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>However, the more idiomatic and efficient way to handle this situation, is to use <code class="docutils literal notranslate"><span class="pre">try</span></code> variants of these functions
instead, which will indicate whether an exception has been thrown in their return value:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">try_convert_to_string</span><span class="p">(</span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Exception thrown.</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zval_try_get_string</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Exception thrown.</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

<span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">tmp_str</span><span class="p">;</span>
<span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_try_get_tmp_string</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp_str</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Exception thrown.</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">zend_tmp_string_release</span><span class="p">(</span><span class="n">tmp_str</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="Link to this heading">¶</a></h2>
<p>Userland operations like <code class="docutils literal notranslate"><span class="pre">$op1</span> <span class="pre">+</span> <span class="pre">$op2</span></code> are implemented through corresponding functions like <code class="docutils literal notranslate"><span class="pre">add_function()</span></code>
internally, which accept a result out-parameter, followed by the input operands:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... */</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... */</span><span class="p">;</span>
<span class="n">zval</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">add_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">op2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FAILURE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Exception thrown.</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Do something with result.</span>
<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>It should be noted that these functions are rather rarely used in practice, as most code works with zvals of specific
types, rather than operating on completely arbitrary values. The full set of functions is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_result</span><span class="w"> </span><span class="nf">add_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">                 </span><span class="cm">/* $result = $op1 + $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">sub_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">                 </span><span class="cm">/* $result = $op1 - $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">mul_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">                 </span><span class="cm">/* $result = $op1 * $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">pow_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">                 </span><span class="cm">/* $result = $op1 ** $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">div_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">                 </span><span class="cm">/* $result = $op1 / $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">mod_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">                 </span><span class="cm">/* $result = $op1 % $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">bitwise_or_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">          </span><span class="cm">/* $result = $op1 | $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">bitwise_and_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">         </span><span class="cm">/* $result = $op1 &amp; $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">bitwise_xor_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">         </span><span class="cm">/* $result = $op1 ^ $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">boolean_xor_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">         </span><span class="cm">/* $result = $op1 xor $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">shift_left_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">          </span><span class="cm">/* $result = $op1 &lt;&lt; $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">shift_right_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">         </span><span class="cm">/* $result = $op1 &gt;&gt; $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">concat_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">              </span><span class="cm">/* $result = $op1 . $op2 */</span>

<span class="n">zend_result</span><span class="w"> </span><span class="nf">bitwise_not_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">);</span><span class="w">                    </span><span class="cm">/* $result = ~$op1 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">boolean_not_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">);</span><span class="w">                    </span><span class="cm">/* $result = !$op1 */</span>

<span class="n">zend_result</span><span class="w"> </span><span class="nf">increment_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span><span class="w">                                     </span><span class="cm">/* ++$op */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">decrement_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span><span class="w">                                     </span><span class="cm">/* --$op */</span>

<span class="n">zend_result</span><span class="w"> </span><span class="nf">compare_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">             </span><span class="cm">/* $result = $op1 &lt;=&gt; $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">is_equal_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">            </span><span class="cm">/* $result = $op1 == $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">is_not_equal_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">        </span><span class="cm">/* $result = $op1 != $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">is_identical_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">        </span><span class="cm">/* $result = $op1 === $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">is_not_identical_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">    </span><span class="cm">/* $result = $op1 !== $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">is_smaller_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w">          </span><span class="cm">/* $result = $op1 &lt; $op2 */</span>
<span class="n">zend_result</span><span class="w"> </span><span class="nf">is_smaller_or_equal_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span><span class="w"> </span><span class="cm">/* $result = $op1 &lt;= $op2 */</span>
<span class="cm">/* $op1 &gt; $op2 is same as $op2 &lt; $op1 */</span>
<span class="cm">/* $op1 &gt;= $op2 is same as $op2 &lt;= $op1 */</span>
</pre></div>
</div>
<p>For comparisons, there are two more variants that return the comparison result, instead of placing it in a zval:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">zend_is_identical</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">zend_compare</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">zend_compare()</span></code> returns a 3-way comparison result like the <code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code> operator in PHP, which is less than, equal to,
or greater than zero depending on whether <code class="docutils literal notranslate"><span class="pre">op1</span></code> is smaller, equal to, or greater than <code class="docutils literal notranslate"><span class="pre">op2</span></code>.</p>
<p>Finally, there are a number of variants that have a <code class="docutils literal notranslate"><span class="pre">fast_</span></code> prefix. These are optimized implementations that
restrict the arguments to certain types, or inline part of the implementation and/or implement it using inline
assembly:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* op1 must have type IS_LONG, implementation uses inline assembly. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">fast_long_increment_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">fast_long_decrement_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">);</span>
<span class="cm">/* op1 and op2 must have type IS_LONG, implementation uses inline assembly. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">fast_long_add_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">fast_long_sub_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="cm">/* op1, op2 may have any type, but IS_LONG and IS_DOUBLE addition is inlined. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="n">zend_result</span><span class="w"> </span><span class="n">fast_add_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="cm">/* op1, op2 may have any type, but IS_LONG, IS_DOUBLE and IS_STRING equality is inlined. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">fast_equal_check_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="cm">/* op1 must have type IS_LONG, op2 can have any type. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">fast_equal_check_long</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="cm">/* op1 must have type IS_DOUBLE, op2 can have any type. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">fast_equal_check_string</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="cm">/* op1, op2 may have any type, but part of the implementation is inlined. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">fast_is_identical_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">fast_is_not_identical_function</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op2</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="references.html">References</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../internal_types.html">Internal types</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>