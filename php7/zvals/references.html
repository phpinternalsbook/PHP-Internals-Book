<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>References &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Casts and operations" href="casts_and_operations.html" />
    <link rel="prev" title="Memory management" href="memory_management.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>References</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="casts_and_operations.html">Casts and operations</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="references">
<h1>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h1>
<p>PHP references (in the sense of the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> symbol) are mostly transparent to userland code, but require consistent
special handling in the implementation. This chapter discusses how references are represented, and how internal code
should deal with them.</p>
<section id="reference-semantics">
<h2>Reference semantics<a class="headerlink" href="#reference-semantics" title="Link to this heading">¶</a></h2>
<p>Before going into the internal representation of PHP references, it may be helpful to clarify some common
misconceptions about the semantics of references in PHP. Consider this basic example:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=&amp;</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$a</span><span class="o">++</span><span class="p">;</span>
<span class="nv">$b</span><span class="o">++</span><span class="p">;</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span> <span class="c1">// int(2)</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span> <span class="c1">// int(2)</span>
</pre></div>
</div>
<p>People will commonly say that “<code class="docutils literal notranslate"><span class="pre">$b</span></code> is a reference to <code class="docutils literal notranslate"><span class="pre">$a</span></code>”. However, this is not quite correct, in that
references in PHP have no concept of directionality. After <code class="docutils literal notranslate"><span class="pre">$b</span> <span class="pre">=&amp;</span> <span class="pre">$a</span></code>, both <code class="docutils literal notranslate"><span class="pre">$a</span></code> and <code class="docutils literal notranslate"><span class="pre">$b</span></code> reference a common
value, and neither of the variables is privileged in any way.</p>
<p>This becomes particularly problematic when we consider the interaction of references and array copies:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nv">$ref</span> <span class="o">=&amp;</span> <span class="nv">$array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nv">$array2</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">;</span>
<span class="nv">$array2</span><span class="p">[]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// Triggering copy-on-write makes no difference here.</span>
<span class="nv">$ref</span><span class="o">++</span><span class="p">;</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// int(1)</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$array2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// int(1)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">$ref</span> <span class="pre">=&amp;</span> <span class="pre">$array[0]</span></code> line creates a reference between <code class="docutils literal notranslate"><span class="pre">$ref</span></code> and <code class="docutils literal notranslate"><span class="pre">$array[0]</span></code>. When the array is subsequently
copied, it becomes a reference between <code class="docutils literal notranslate"><span class="pre">$ref</span></code>, <code class="docutils literal notranslate"><span class="pre">$array[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">$array2[0]</span></code>, as the reference is also copied.</p>
<p>Intuitively this behavior is wrong. There’s two reasons why it happens: The first one is the aforementioned lack
of directionality. This behavior <em>would</em> make sense if we had written <code class="docutils literal notranslate"><span class="pre">$array[0]</span> <span class="pre">=&amp;</span> <span class="pre">$ref</span></code>. In this case it would be
expected that a copy of <code class="docutils literal notranslate"><span class="pre">$array2[0]</span></code> also points to <code class="docutils literal notranslate"><span class="pre">$ref</span></code>. However, we cannot actually distinguish these two
cases.</p>
<p>The second and more important reason is a more technical one: <code class="docutils literal notranslate"><span class="pre">$array2</span> <span class="pre">=</span> <span class="pre">$array</span></code> only performs a refcount increment,
which means we wouldn’t have a chance to drop the reference even if we wanted to.</p>
</section>
<section id="representation">
<h2>Representation<a class="headerlink" href="#representation" title="Link to this heading">¶</a></h2>
<p>References are represented using an <code class="docutils literal notranslate"><span class="pre">IS_REFERENCE</span></code> zval that points to a <code class="docutils literal notranslate"><span class="pre">zend_reference</span></code> structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">_zend_reference</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zend_refcounted_h</span><span class="w">              </span><span class="n">gc</span><span class="p">;</span>
<span class="w">    </span><span class="n">zval</span><span class="w">                           </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="n">zend_property_info_source_list</span><span class="w"> </span><span class="n">sources</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Zvals themselves do not have a reference count, and cannot be shared. The <code class="docutils literal notranslate"><span class="pre">zend_reference</span></code> structure essentially
represents a reference-counted zval that <em>can</em> be shared. Multiple zvals can point to the same <code class="docutils literal notranslate"><span class="pre">zend_reference</span></code>,
and any change to the <code class="docutils literal notranslate"><span class="pre">val</span></code> it contains will be observable from all sources.</p>
<section id="type-sources">
<h3>Type sources<a class="headerlink" href="#type-sources" title="Link to this heading">¶</a></h3>
<p>Normally, PHP does not track who or what makes use of a given reference. The only knowledge that is stored is how many
users there are (through the refcount), so that the reference may be destroyed in time.</p>
<p>However, due to the introduction of typed properties in PHP 7.4, we do need to track of which typed properties make
use of a certain reference, in order to enforce property types for indirect modifications through references:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nx">int</span> <span class="nv">$prop</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="nv">$test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">;</span>
<span class="nv">$ref</span> <span class="o">=&amp;</span> <span class="nv">$test</span><span class="o">-&gt;</span><span class="na">prop</span><span class="p">;</span>
<span class="nv">$ref</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span><span class="p">;</span> <span class="c1">// TypeError</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">sources</span></code> member of <code class="docutils literal notranslate"><span class="pre">zend_reference</span></code> stores a list of <code class="docutils literal notranslate"><span class="pre">zend_property_info</span></code> pointers to track typed properties
that use the reference. Macros like <code class="docutils literal notranslate"><span class="pre">ZEND_REF_HAS_TYPE_SOURCES()</span></code>, <code class="docutils literal notranslate"><span class="pre">ZEND_REF_ADD_TYPE_SOURCE()</span></code>, and
<code class="docutils literal notranslate"><span class="pre">ZEND_REF_DEL_TYPE_SOURCE()</span></code> are used to manage this source list, but typically only engine code needs to deal with
this.</p>
</section>
</section>
<section id="initializing-references">
<h2>Initializing references<a class="headerlink" href="#initializing-references" title="Link to this heading">¶</a></h2>
<p>Just like other zvals, references are initialized through a set of macros. The most basic one accepts an already
created <code class="docutils literal notranslate"><span class="pre">zend_reference</span></code> pointer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span>
<span class="n">ZVAL_REF</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span><span class="w"> </span><span class="n">zend_reference_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>To create a reference from scratch, <code class="docutils literal notranslate"><span class="pre">ZVAL_NEW_REF()</span></code> can be used:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span>
<span class="n">zval</span><span class="w"> </span><span class="n">initial_val</span><span class="p">;</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">initial_val</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="p">);</span>
<span class="n">ZVAL_NEW_REF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">initial_val</span><span class="p">);</span>
</pre></div>
</div>
<p>This macro accepts an initial value for the reference. Note that it is <em>moved</em> into the reference using
<code class="docutils literal notranslate"><span class="pre">ZVAL_COPY_VALUE</span></code>, the refcount is not incremented. Alternatively, <code class="docutils literal notranslate"><span class="pre">ZVAL_NEW_EMPTY_REF()</span></code> leaves the value
uninitialized:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span>
<span class="n">ZVAL_NEW_EMPTY_REF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">Z_REFVAL</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we create an empty reference and then initialize the reference value <code class="docutils literal notranslate"><span class="pre">Z_REFVAL(ref)</span></code> directly. Finally,
<code class="docutils literal notranslate"><span class="pre">ZVAL_MAKE_REF()</span></code> can be used to promote an existing zval into a reference:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... */</span><span class="p">;</span>
<span class="n">ZVAL_MAKE_REF</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">zv</span></code> was already a reference, this does nothing. It if wasn’t a reference yet, this will change <code class="docutils literal notranslate"><span class="pre">zv</span></code> into a
reference and set its initial value to the old value of <code class="docutils literal notranslate"><span class="pre">zv</span></code>.</p>
</section>
<section id="dereferencing-and-unwrapping">
<h2>Dereferencing and unwrapping<a class="headerlink" href="#dereferencing-and-unwrapping" title="Link to this heading">¶</a></h2>
<p>Most code does not want to handle references in any special way, and simply want to look through to the underlying
value:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">zv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... */</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_ISREF_P</span><span class="p">(</span><span class="n">zv</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Z_REFVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the value is a reference (<code class="docutils literal notranslate"><span class="pre">Z_ISREF</span></code>), we switch to looking at the value it contains. This operation is called
“dereferencing” and is more compactly written as <code class="docutils literal notranslate"><span class="pre">ZVAL_DEREF(zv)</span></code>. It is extremely common and should be applied
essentially at any point where reference zvals might occur. For example, this is how a typical loop over an array
might look like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">;</span>
<span class="n">ZEND_HASH_FOREACH_VAL</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ZVAL_DEREF</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Do something with val, now a guaranteed non-reference. */</span>
<span class="p">}</span><span class="w"> </span><span class="n">ZEND_HASH_FOREACH_END</span><span class="p">();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ZVAL_COPY_DEREF(target,</span> <span class="pre">source)</span></code> macro is a combined form of <code class="docutils literal notranslate"><span class="pre">ZVAL_COPY</span></code> and <code class="docutils literal notranslate"><span class="pre">ZVAL_DEREF</span></code>. It copies the
dereferenced value of <code class="docutils literal notranslate"><span class="pre">source</span></code> into <code class="docutils literal notranslate"><span class="pre">target</span></code>.</p>
<p>Dereferencing simply moves a pointer from the outer to the inner zval, without changing either. It is also possible
to actually remove the reference wrapper by performing an unwrap. It is probably easiest to understand this operation
by looking at its implementation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">zend_always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">zend_unwrap_reference</span><span class="p">(</span><span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Z_REFCOUNT_P</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ZVAL_UNREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Z_DELREF_P</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="w">        </span><span class="n">ZVAL_COPY</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">Z_REFVAL_P</span><span class="p">(</span><span class="n">op</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the refcount is 1, then the inner value is moved into <code class="docutils literal notranslate"><span class="pre">op</span></code> and the reference wrapper is destroyed. This is what
<code class="docutils literal notranslate"><span class="pre">ZVAL_UNREF()</span></code> does. If the refcount is greater than one, then we decrement the refcount of the reference wrapper,
and copy (with refcount increase) the inner value into <code class="docutils literal notranslate"><span class="pre">op</span></code>. This means that an unwrap operation does not necessarily
destroy the reference (if it has other users), but will remove one particular use.</p>
</section>
<section id="indirect-zvals">
<h2>Indirect zvals<a class="headerlink" href="#indirect-zvals" title="Link to this heading">¶</a></h2>
<p>Next to references, PHP also has a more direct mechanism to share zvals. The <code class="docutils literal notranslate"><span class="pre">IS_INDIRECT</span></code> type stores a direct
pointer to another zval:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zval</span><span class="w"> </span><span class="n">val1</span><span class="p">;</span>
<span class="n">ZVAL_LONG</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val1</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>

<span class="n">zval</span><span class="w"> </span><span class="n">val2</span><span class="p">;</span>
<span class="n">ZVAL_INDIRECT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val1</span><span class="p">);</span>

<span class="n">ZEND_ASSERT</span><span class="p">(</span><span class="n">Z_INDIRECT</span><span class="p">(</span><span class="n">val2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val1</span><span class="p">);</span>
</pre></div>
</div>
<p>While there is some surface similarity to references, this mechanism is not generally usable, because nothing ensures
that the pointed-to zval isn’t deallocated. For this reason, indirect zvals can only be used in controlled situations,
for example to point from a property hash table to a property slot table. This is possible, because we know that the
property slot table is not reallocated during the lifetime of an object, and the property hash table and property slot
table are deallocated at the same time, so no dangling pointers are left behind.</p>
<p>As such, indirect zvals can only occur in specific situations, and cannot be stored in general-purpose userland-exposed
zvals.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="casts_and_operations.html">Casts and operations</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>