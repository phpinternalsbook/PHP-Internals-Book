
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Learning the PHP lifecycle &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="A look into a PHP extension and extension skeleton" href="extension_skeleton.html" />
    <link rel="prev" title="Extensions design" href="../extensions_design.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Learning the PHP lifecycle</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../extensions_design.html">Extensions design</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="extension_skeleton.html">A look into a PHP extension and extension skeleton</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="learning-the-php-lifecycle">
<span id="php-lifecycle"></span><h1>Learning the PHP lifecycle<a class="headerlink" href="#learning-the-php-lifecycle" title="Permalink to this heading">¶</a></h1>
<p>PHP is a complex piece of machinery whose lifecycle really should be understood by anyone who wants to understand how PHP operates. The main sequence is as follows:</p>
<p>PHP starts up. If running CLI or FPM, it’s C <code class="docutils literal notranslate"><span class="pre">main()</span></code> is run. If running as a module into a webserver, like using the
apxs2 SAPI (Apache 2), PHP is started up just a little bit after Apache itself starts up and comes to run the startup
sequence of its module which PHP is one. Starting up, is called internally <strong>the module startup step</strong>. We also
abbreviate it as the <strong>MINIT</strong> step.</p>
<p>Once started, PHP waits to handle one/several requests. When we talk about PHP CLI, there will be only one request: the
current script to run. However, when we talk about a web environment- should it be PHP-FPM or webserver
module- PHP could serve several requests one after the other. It all depends on how you did configure you webserver:
you may tell it to serve an infinite number of requests, or a specific number before shutting down and recycling the
process. Every time a new request arrives to be handled, PHP will run <strong>a request startup step</strong>. We call it the
<strong>RINIT</strong>.</p>
<p>The request is served, some content is (probably) generated, OK. Time to shutdown the request and get prepared to
eventually handle another one. Shutting down a request is called <strong>the request shutdown step</strong>.  We call
it the <strong>RSHUTDOWN</strong>.</p>
<p>After having handled X requests (one, several dozens, thousands etc..), PHP will finally shut down itself, and die.
Shutting down the PHP process is called <strong>the module shutdown step</strong>. We abbreviate it as <strong>MSHUTDOWN</strong>.</p>
<p>If we would have drawn those steps, that could give something like this:</p>
<img alt="../../_images/php_classic_lifetime.png" class="align-center" src="../../_images/php_classic_lifetime.png" />
<section id="the-parallelism-models">
<h2>The parallelism models<a class="headerlink" href="#the-parallelism-models" title="Permalink to this heading">¶</a></h2>
<p>In a CLI environment, everything is easy : one PHP process will handle one request : it will launch one solo PHP script,
then die.
The CLI environment is a specialization of the Web environment, which is more complex.</p>
<p>To handle several requests at the same time, you need to run a parallelism model. There exists two of them in PHP:</p>
<ul class="simple">
<li><p>The process-based model</p></li>
<li><p>The thread-based model</p></li>
</ul>
<p>Using the process-based model, every PHP interpreter is isolated by the OS into its own process.
This model is very common under Unix. Every request leaves into its own process.
This model is used by PHP-CLI, PHP-FPM and PHP-CGI.</p>
<p>With the thread-based model, every PHP interpreter is isolated into a thread, using a thread library.
This model is mainly used under Microsoft Windows OS, but can be used with most Unixes as well. This requires PHP and
its extensions <a class="reference internal" href="../build_system/building_extensions.html"><span class="doc">to be built</span></a> in ZTS mode.</p>
<p>Here is the process-based model:</p>
<img alt="../../_images/php_lifetime_process.png" class="align-center" src="../../_images/php_lifetime_process.png" />
<p>And here is the thread-based model:</p>
<img alt="../../_images/php_lifetime_thread.png" class="align-center" src="../../_images/php_lifetime_thread.png" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PHP’s multi-processing module is not of your choice, as an extension developer. You will have to support it.
You will have to support the fact that your extension could run in a threaded environment, especially under
Windows platforms, and you’ll have to program against it.</p>
</div>
</section>
<section id="the-php-extensions-hooks">
<h2>The PHP extensions hooks<a class="headerlink" href="#the-php-extensions-hooks" title="Permalink to this heading">¶</a></h2>
<p>As you could have guessed, the PHP engine will trigger your extension at several lifetime points. We call those <em>hook
functions</em>. Your extension may declare interest into specific lifetime points by declaring function hooks while it
registers against the engine.</p>
<p>Those hooks can clearly be noticed once you analyze a PHP extension structure, the <code class="docutils literal notranslate"><span class="pre">zend_module_entry</span></code> structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">_zend_module_entry</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zend_api</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">zend_debug</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">zts</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_zend_ini_entry</span><span class="w"> </span><span class="o">*</span><span class="n">ini_entry</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_zend_module_dep</span><span class="w"> </span><span class="o">*</span><span class="n">deps</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_zend_function_entry</span><span class="w"> </span><span class="o">*</span><span class="n">functions</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">module_startup_func</span><span class="p">)(</span><span class="n">INIT_FUNC_ARGS</span><span class="p">);</span><span class="w">        </span><span class="cm">/* MINIT() */</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">module_shutdown_func</span><span class="p">)(</span><span class="n">SHUTDOWN_FUNC_ARGS</span><span class="p">);</span><span class="w">   </span><span class="cm">/* MSHUTDOWN() */</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">request_startup_func</span><span class="p">)(</span><span class="n">INIT_FUNC_ARGS</span><span class="p">);</span><span class="w">       </span><span class="cm">/* RINIT() */</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">request_shutdown_func</span><span class="p">)(</span><span class="n">SHUTDOWN_FUNC_ARGS</span><span class="p">);</span><span class="w">  </span><span class="cm">/* RSHUTDOWN() */</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">info_func</span><span class="p">)(</span><span class="n">ZEND_MODULE_INFO_FUNC_ARGS</span><span class="p">);</span><span class="w">     </span><span class="cm">/* PHPINFO() */</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">version</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">globals_size</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef ZTS</span>
<span class="w">        </span><span class="n">ts_rsrc_id</span><span class="o">*</span><span class="w"> </span><span class="n">globals_id_ptr</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">        </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">globals_ptr</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">globals_ctor</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">global</span><span class="p">);</span><span class="w">                </span><span class="cm">/* GINIT() */</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">globals_dtor</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">global</span><span class="p">);</span><span class="w">                </span><span class="cm">/* GSHUTDOWN */</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">post_deactivate_func</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span><span class="w">                 </span><span class="cm">/* PRSHUTDOWN() */</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">module_started</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">module_number</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">build_id</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Let’s now have a look at what kind of code you should write in any of those hooks.</p>
<section id="module-initialization-minit">
<h3>Module initialization: MINIT()<a class="headerlink" href="#module-initialization-minit" title="Permalink to this heading">¶</a></h3>
<p>This is PHP process startup step. In your extension’s <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code>, you’ll load and allocate any persistent object or
piece of information you’ll need for every future request.
For the big part of them, those allocations will target read-only objects.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code>, no thread or process has popped yet, so you may fully access global variables with no protection at
all. Also, you must not allocate memory that is request-bound, as a request has not started yet.
You never use <a class="reference internal" href="../memory_management/zend_memory_manager.html"><span class="doc">Zend Memory Manager</span></a> allocations in <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code> steps,
but persistent allocations. No <code class="docutils literal notranslate"><span class="pre">emalloc()</span></code>, but <code class="docutils literal notranslate"><span class="pre">pemalloc()</span></code>. Failing to do that will lead to crashes.</p>
<p>At <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code>, the execution engine is not started yet, so beware of not trying to access any of its structure without
special care.</p>
<p>If you need to register INI entries for your extension, <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code> is the right step to do that.</p>
<p>If you need to register read-only <a class="reference internal" href="../internal_types/strings.html"><span class="doc">zend_strings</span></a> for further usage, it is time to do so
here (with persistent alloc).</p>
<p>If you need to allocate objects that well be written to while serving a request, then you’ll need to duplicate their
memory allocation to a thread-specific pool for the request. Remember that you can only write safely to global space
while into <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Memory management, allocations, and debugging; are part of the <a class="reference internal" href="../memory_management.html"><span class="doc">memory management</span></a>
chapter.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MINIT()</span></code> is triggered by <code class="docutils literal notranslate"><span class="pre">zend_startup_modules()</span></code> in
<a class="reference external" href="https://github.com/php/php-src/blob/3704947696fe0ee93e025fa85621d297ac7a1e4d/main/main.c#L2009">php_module_startup()</a>
function.</p>
</section>
<section id="module-termination-mshutdown">
<h3>Module termination: MSHUTDOWN()<a class="headerlink" href="#module-termination-mshutdown" title="Permalink to this heading">¶</a></h3>
<p>This is PHP process shutdown step. Easy enough, you basically perform here the exact opposite of what you used in
<code class="docutils literal notranslate"><span class="pre">MINIT()</span></code>. You free your resources, you unregister your INI settings, etc..</p>
<p>Take care again here: the execution engine is shut down, so you should not access any of its variable (but you should
not need to here).</p>
<p>As you don’t live in a request here, you should not free resources using
<a class="reference internal" href="../memory_management/zend_memory_manager.html"><span class="doc">Zend Memory Manager</span></a> <code class="docutils literal notranslate"><span class="pre">efree()</span></code> or alikes, but free for persistent
allocations, aka <code class="docutils literal notranslate"><span class="pre">pefree()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MSHUTDOWN()</span></code> is triggered by <code class="docutils literal notranslate"><span class="pre">zend_destroy_modules()</span></code> from <code class="docutils literal notranslate"><span class="pre">zend_shutdown()</span></code> in
<a class="reference external" href="https://github.com/php/php-src/blob/3704947696fe0ee93e025fa85621d297ac7a1e4d/main/main.c#L2335">php_module_shutdown()</a>
function.</p>
</section>
<section id="request-initialization-rinit">
<h3>Request initialization: RINIT()<a class="headerlink" href="#request-initialization-rinit" title="Permalink to this heading">¶</a></h3>
<p>A request just showed in, and PHP is about to handle it here. In <code class="docutils literal notranslate"><span class="pre">RINIT()</span></code>, you bootstrap the resources you need to
handle that precise request. PHP is a share-nothing architecture, and as-is, it provides
<a class="reference internal" href="../memory_management.html"><span class="doc">memory management</span></a> facilities.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">RINIT()</span></code>, if you need to allocate dynamic memory, you’ll use
<a class="reference internal" href="../memory_management/zend_memory_manager.html"><span class="doc">Zend Memory Manager</span></a>. You will call for <code class="docutils literal notranslate"><span class="pre">emalloc()</span></code>.
<a class="reference internal" href="../memory_management/zend_memory_manager.html"><span class="doc">Zend Memory Manager</span></a> tracks the memory you allocate through it, and
when the request shuts down, it will attempt to free the request-bound memory if you forgot to do so (you should not).</p>
<p>You should not require persistent dynamic memory here, aka libc’s <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or Zend’s <code class="docutils literal notranslate"><span class="pre">pemalloc()</span></code>. If you require
persistent memory here, and forgets to free it, you’ll create leaks that will stack as PHP handles more and more
requests, to finally crash the process (Kernel OOM) and starve the machine memory.</p>
<p>Also, take great care not to write to global space here. If PHP is run into a thread as chosen parallelism model, then
you’ll modify the context for every thread of the pool (every other request handled in parallel to yours) and you could
also trigger race conditions if you don’t lock the memory.
If you need globals, you’ll need to protect them.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Global scope management is explained into <a class="reference internal" href="globals_management.html"><span class="doc">a dedicated  chapter</span></a>.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">RINIT()</span></code> is triggered by <code class="docutils literal notranslate"><span class="pre">zend_activate_module()</span></code> in
<a class="reference external" href="https://github.com/php/php-src/blob/3704947696fe0ee93e025fa85621d297ac7a1e4d/main/main.c#L1558">php_request_startup()</a>
function.</p>
</section>
<section id="request-termination-rshutdown">
<h3>Request termination: RSHUTDOWN()<a class="headerlink" href="#request-termination-rshutdown" title="Permalink to this heading">¶</a></h3>
<p>This is PHP request shutdown step. PHP just finished handling its request, and now it cleans up part of its memory as
the share-nothing architecture. Further request to come should not remember anything from the current request.
Easy enough, you basically perform here the exact opposite of what you used in <code class="docutils literal notranslate"><span class="pre">RINIT()</span></code>. You free your request-bound
resources.</p>
<p>As you live in a request here, you should free resources using Zend Memory Manager <code class="docutils literal notranslate"><span class="pre">efree()</span></code> or alikes.
If you forget to free and leak, on debug builds, the memory manager will push on process <em>stderr</em> a log about the
pointers you are leaking, and it will free them for you.</p>
<p>To give you an idea, <code class="docutils literal notranslate"><span class="pre">RSHUTDOWN()</span></code> is called:</p>
<ul class="simple">
<li><p>After userland shutdown functions have been executed (<code class="docutils literal notranslate"><span class="pre">register_shutdown_function()</span></code>)</p></li>
<li><p>After every object destructor have been called</p></li>
<li><p>After PHP output buffer has been flushed</p></li>
<li><p>After max_execution_time has been disabled</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">RSHUTDOWN()</span></code> is triggered by <code class="docutils literal notranslate"><span class="pre">zend_deactivate_modules()</span></code> in
<a class="reference external" href="https://github.com/php/php-src/blob/3704947696fe0ee93e025fa85621d297ac7a1e4d/main/main.c#L1758">php_request_shutdown()</a>
function.</p>
</section>
<section id="request-post-termination-prshutdown">
<h3>Request Post termination: PRSHUTDOWN()<a class="headerlink" href="#request-post-termination-prshutdown" title="Permalink to this heading">¶</a></h3>
<p>This hook is rarely used. It is called after <code class="docutils literal notranslate"><span class="pre">RSHUTDOWN()</span></code>, but some additional engine code runs in-between.</p>
<p>Especially, in Post-RSHUTDOWN:</p>
<ul class="simple">
<li><p>The PHP output buffer has been closed and its handlers flushed</p></li>
<li><p>PHP super-globals have been destroyed</p></li>
<li><p>The execution engine has been shut down</p></li>
</ul>
<p>This hook is very rare to use. It is triggered a little bit after <code class="docutils literal notranslate"><span class="pre">RSHUTDOWN()</span></code>, by <code class="docutils literal notranslate"><span class="pre">zend_post_deactivate_modules()</span></code> in
<a class="reference external" href="https://github.com/php/php-src/blob/3704947696fe0ee93e025fa85621d297ac7a1e4d/main/main.c#L1758">php_request_shutdown()</a>
function.</p>
</section>
<section id="globals-initialization-ginit">
<h3>Globals initialization: GINIT()<a class="headerlink" href="#globals-initialization-ginit" title="Permalink to this heading">¶</a></h3>
<p>This hook is called every time a thread is popped by the Threading library. If you use processes as multi-processing
facility, this function is called only once, while PHP is starting up, just before <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code> gets triggered.</p>
<p>Not providing too many details here, you simply should initialize your globals here, usually to the value zero.
Globals management will be covered in its dedicated chapter.</p>
<p>Remember that globals are not cleared after every request. If you need to reset them for every new request (likely),
then you need to put such a procedure into <code class="docutils literal notranslate"><span class="pre">RINIT()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Global scope management is explained into <a class="reference internal" href="globals_management.html"><span class="doc">a dedicated  chapter</span></a>.</p>
</div>
</section>
<section id="globals-termination-gshutdown">
<h3>Globals termination: GSHUTDOWN()<a class="headerlink" href="#globals-termination-gshutdown" title="Permalink to this heading">¶</a></h3>
<p>This hook is called every time a thread dies from the Threading library. If you use processes as multi-processing
facility, this function is called only once, as part of PHP shutdown (during <code class="docutils literal notranslate"><span class="pre">MSHUTDOWN()</span></code>).</p>
<p>Not providing too many details here, you simply should de-initialize your globals here, usually you have nothing to do,
but if you allocated resources while constructing globals (<code class="docutils literal notranslate"><span class="pre">GINIT()</span></code>), here is the step where you should release them.</p>
<p>Globals management will be covered in its dedicated chapter.</p>
<p>Remember that globals are not cleared after every request; aka <code class="docutils literal notranslate"><span class="pre">GSHUTDOWN()</span></code> is not called as part of <code class="docutils literal notranslate"><span class="pre">RSHUTDOWN()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Global scope management is explained into <a class="reference internal" href="globals_management.html"><span class="doc">a dedicated  chapter</span></a>.</p>
</div>
</section>
<section id="information-gathering-minfo">
<h3>Information gathering: MINFO()<a class="headerlink" href="#information-gathering-minfo" title="Permalink to this heading">¶</a></h3>
<p>That hook is special as it is never triggered automatically by the engine, but only when you ask it information about
an extension. The typical use case is a call to <code class="docutils literal notranslate"><span class="pre">phpinfo()</span></code>. This function is then run, and it is expected to print
into a stream special information about the current extension.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">phpinfo()</span></code> panel information, in short.</p>
<p>This function can also be called through the CLI, using one of the reflection switch such as <code class="docutils literal notranslate"><span class="pre">php</span> <span class="pre">--ri</span> <span class="pre">pib</span></code> or via
userland with a call to <code class="docutils literal notranslate"><span class="pre">ini_get_all()</span></code> f.e</p>
<p>You may leave it empty, in such a case only the name of the extension is displayed and nothing more (possible INI
settings are not displayed as this happens as part of MINFO()).</p>
</section>
<section id="thoughts-on-php-lifecycle">
<h3>Thoughts on PHP lifecycle<a class="headerlink" href="#thoughts-on-php-lifecycle" title="Permalink to this heading">¶</a></h3>
<img alt="../../_images/php_extensions_lifecycle.png" class="align-center" src="../../_images/php_extensions_lifecycle.png" />
<p>As you may have spotted, <code class="docutils literal notranslate"><span class="pre">RINIT()</span></code> and <code class="docutils literal notranslate"><span class="pre">RSHUTDOWN()</span></code> are especially crucial as they could get triggered thousands
of times on your extension. If the PHP setup is about Web (not CLI), and has been configured so that it can handle an
infinite number of requests, thus your <code class="docutils literal notranslate"><span class="pre">RINIT()/RSHUTDOWN()</span></code> couple will be called an infinite amount of time.</p>
<p>We’d like to once more get your attention about memory management. The little tiny byte you’ll eventually leak while
handling a request (between <code class="docutils literal notranslate"><span class="pre">RINIT()</span></code> and <code class="docutils literal notranslate"><span class="pre">RSHUTDOWN()</span></code>) will have dramatic consequences on fully loaded servers.
That’s why you are advised to use <a class="reference internal" href="../memory_management/zend_memory_manager.html"><span class="doc">Zend Memory Manager</span></a> for such
allocations and be ready to <a class="reference internal" href="../memory_management/memory_debugging.html"><span class="doc">debug your memory layout</span></a>. PHP will forget
and free the request memory at the end of every request as part of the share-nothing architecture, that’s PHP’s
internal design.</p>
<p>Also, if you crash with a SIGSEGV signal (bad memory access), you crash the entire process. If the PHP setup was using
threads as multi-processing engine, then you crash every other thread with you, and could even crash the webserver.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The C language is not the PHP language. Using C, errors and mistakes in your program will highly probably
lead to a program crash and termination.</p>
</div>
</section>
</section>
<section id="hooking-by-overwriting-function-pointers">
<h2>Hooking by overwriting function pointers<a class="headerlink" href="#hooking-by-overwriting-function-pointers" title="Permalink to this heading">¶</a></h2>
<p>Now you know when the engine will trigger your code, there exists also noticeable function pointers you may replace to
hook into the engine.
As those pointers are global variables, you may replace them into <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code> step, and put them back into
<code class="docutils literal notranslate"><span class="pre">MSHUTDOWN()</span></code>.</p>
<p>Those of interest are:</p>
<ul class="simple">
<li><dl class="simple">
<dt>AST, Zend/zend_ast.h:</dt><dd><ul>
<li><p><cite>void (*zend_ast_process_t)(zend_ast *ast)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Compiler, Zend/zend_compile.h:</dt><dd><ul>
<li><p><cite>zend_op_array *(*zend_compile_file)(zend_file_handle *file_handle, int type)</cite></p></li>
<li><p><cite>zend_op_array *(*zend_compile_string)(zval *source_string, char *filename)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Executor, Zend/zend_execute.h:</dt><dd><ul>
<li><p><cite>void (*zend_execute_ex)(zend_execute_data *execute_data)</cite></p></li>
<li><p><cite>void (*zend_execute_internal)(zend_execute_data *execute_data, zval *return_value)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>GC, Zend/zend_gc.h:</dt><dd><ul>
<li><p><cite>int (*gc_collect_cycles)(void)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>TSRM, TSRM/TSRM.h:</dt><dd><ul>
<li><p><cite>void (*tsrm_thread_begin_func_t)(THREAD_T thread_id)</cite></p></li>
<li><p><cite>void (*tsrm_thread_end_func_t)(THREAD_T thread_id)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Error, Zend/zend.h:</dt><dd><ul>
<li><p><cite>void (*zend_error_cb)(int type, const char *error_filename, const uint error_lineno, const char *format,
va_list args)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Exceptions, Zend/zend_exceptions.h:</dt><dd><ul>
<li><p><cite>void (*zend_throw_exception_hook)(zval *ex)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Lifetime, Zend/zend.h:</dt><dd><ul>
<li><p><cite>void (*zend_on_timeout)(int seconds)</cite></p></li>
<li><p><cite>void (*zend_interrupt_function)(zend_execute_data *execute_data)</cite></p></li>
<li><p><cite>void (*zend_ticks_function)(int ticks)</cite></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Other exists but the above ones are the most important ones you could need while designing PHP extensions.
As their names are self explanatory, there is no need to detail every of them.</p>
<p>If you need some more information, you can look for them into PHP source code, and discover when and how they get
triggered.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../extensions_design.html">Extensions design</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="extension_skeleton.html">A look into a PHP extension and extension skeleton</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>