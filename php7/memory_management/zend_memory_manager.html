<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Zend Memory Manager &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Debugging memory" href="memory_debugging.html" />
    <link rel="prev" title="Memory management" href="../memory_management.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Zend Memory Manager</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="memory_debugging.html">Debugging memory</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="zend-memory-manager">
<span id="zend-mm"></span><h1>Zend Memory Manager<a class="headerlink" href="#zend-memory-manager" title="Link to this heading">¶</a></h1>
<p>Zend Memory Manager, often abbreviated as <em>ZendMM</em> or <em>ZMM</em>, is a C layer that aims to provide abilities to allocate
and release dynamic <strong>request-bound</strong> memory.</p>
<p>Note the “request-bound” in the above sentence.</p>
<p>ZendMM is not just a classical layer over libc’s dynamic memory allocator, mainly represented by the couple API calls
<code class="docutils literal notranslate"><span class="pre">malloc()/free()</span></code>. ZendMM is about request-bound memory that PHP must allocate while treating a request.</p>
<section id="the-two-main-kind-of-dynamic-memory-pools-in-php">
<h2>The two main kind of dynamic memory pools in PHP<a class="headerlink" href="#the-two-main-kind-of-dynamic-memory-pools-in-php" title="Link to this heading">¶</a></h2>
<p>PHP is a share-nothing architecture. Well, not at 100%. Let us explain.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You may need to read <a class="reference internal" href="../extensions_design/php_lifecycle.html"><span class="doc">the PHP lifecycle chapter</span></a> before continuing
here, you’ll get additional information about the different steps and cycles that can be drawn from PHP
lifetime.</p>
</div>
<p>PHP can treat several hundreds or thousands of requests into the same process. By default, PHP will forget anything it
knows of the current request, when that later finishes.</p>
<p>“Forgetting” things translates to freeing any dynamic buffer that got allocated while treating a request. That means
that when in the process of treating a request, one must not allocate dynamic memory using traditional libc calls.
Doing that is perfectly valid, but you give a chance to forget to free such a buffer.</p>
<p>ZendMM comes with an API that substitute to libc’s dynamic allocator, by copying its API. When in the process of
treating a request, the programmer must use that API instead of libc’s allocator.</p>
<p>For example, when PHP treats a request, it will parse PHP files. Those ones will lead to functions and classes
declarations, for example. When the compiler comes to compile the PHP files, it will allocate some dynamic memory to
store classes and functions it discovers. But, at the end of the request, PHP will forget about those latter. By
default, PHP forgets <em>a very huge number</em> of information from one request to another.</p>
<p>There exists however some pretty rare information you need to persist across several requests. But that’s uncommon.</p>
<p>What could be kept unchanged through requests ? What we call <strong>persistent</strong> objects. Once more let us insist : those
are rare cases. For example, the current PHP executable path won’t change from requests to requests. That latter
information is allocated permanently, that means it is allocated with a traditional libc’s <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> call.</p>
<p>What else? Some strings. For example, the <em>“_SERVER”</em> string will be reused from request to request, as every request
will create the <code class="docutils literal notranslate"><span class="pre">$_SERVER</span></code> PHP array. So the <em>“_SERVER”</em> string itself can be permanently allocated, because it will
be allocated once.</p>
<p>What you must remember:</p>
<ul class="simple">
<li><dl class="simple">
<dt>There exists two kinds of dynamic memory allocations while programming PHP Core or extensions:</dt><dd><ul>
<li><p>Request-bound dynamic allocations.</p></li>
<li><p>Permanent dynamic allocations.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Request-bound dynamic memory allocations</dt><dd><ul>
<li><p>Must only be performed when PHP is treating a request (not before, nor after).</p></li>
<li><p>Should only be performed using the ZendMM dynamic memory allocation API.</p></li>
<li><p>Are very common in extensions design, basically 95% of your dynamic allocations will be request-bound.</p></li>
<li><p>Are tracked by ZendMM, and you’ll be informed about leaking.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Permanent dynamic memory allocations</dt><dd><ul>
<li><p>Should not be performed while PHP is treating a request (not forbidden, but a bad idea).</p></li>
<li><p>Are not tracked by ZendMM, and you won’t be informed about leaking.</p></li>
<li><p>Should be pretty rare in an extension.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Also, keep in mind that all PHP source code has been based on such a memory level. Thus, many internal structures get
allocated using the Zend Memory Manager. Most of them got a “persistent” API call, which when used, lead to
traditional libc allocation.</p>
<p>Here is a request-bound allocated <a class="reference internal" href="../internal_types/strings/zend_strings.html"><span class="doc">zend_string</span></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>And here is the persistent allocated one:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Same for <a class="reference internal" href="../internal_types/hashtables.html"><span class="doc">HashTable</span></a>. Request-bound allocated one:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_array</span><span class="w"> </span><span class="n">ar</span><span class="p">;</span>
<span class="n">zend_hash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Persistent allocated one:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_array</span><span class="w"> </span><span class="n">ar</span><span class="p">;</span>
<span class="n">zend_hash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>It is always the same in all the different Zend APIs. Usually, it is whether a <em>“0”</em> to pass as last parameter to mean
“I want this structure to be allocated using ZendMM, so request-bound”, or <em>“1”</em> meaning “I want this structure to get
allocated bypassing ZendMM and using a traditional libc’s <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> call”.</p>
<p>Obviously, those structures provide an API that remembers how it did allocate the structure, to use the right
deallocation function when destroyed. Hence in such a code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">zend_hash_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>
</pre></div>
</div>
<p>The API knows whether those structures were allocated using request-bound allocation, or permanent one, and in the
first case will use <code class="docutils literal notranslate"><span class="pre">efree()</span></code> to release it, and in the second case libc’s <code class="docutils literal notranslate"><span class="pre">free()</span></code>.</p>
</section>
<section id="zend-memory-manager-api">
<h2>Zend Memory Manager API<a class="headerlink" href="#zend-memory-manager-api" title="Link to this heading">¶</a></h2>
<p>The API is located into
<a class="reference external" href="https://github.com/php/php-src/blob/c3b910370c5c92007c3e3579024490345cb7f9a7/Zend/zend_alloc.h">Zend/zend_alloc.h</a></p>
<p>The API calls are mainly C macros and not functions, so get prepared if you debug them and want to look at how they
work. Those calls copy libc’s calls, they usually add an “e” in the function name; So you should not be lost, and there
is not many things to detail about the API.</p>
<p>Basically what you’ll use most are <code class="docutils literal notranslate"><span class="pre">emalloc(size_t)</span></code> and <code class="docutils literal notranslate"><span class="pre">efree(void</span> <span class="pre">*)</span></code>.</p>
<p>You are also provided with <code class="docutils literal notranslate"><span class="pre">ecalloc(size_t</span> <span class="pre">nmemb,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code> that allocates <code class="docutils literal notranslate"><span class="pre">nmemb</span></code> of individual size <code class="docutils literal notranslate"><span class="pre">size</span></code>,
and zeroes the area. If you are a strong C programmer with experience, you should know that whenever possible, it is
better to use <code class="docutils literal notranslate"><span class="pre">ecalloc()</span></code> over <code class="docutils literal notranslate"><span class="pre">emalloc()</span></code> as <code class="docutils literal notranslate"><span class="pre">ecalloc()</span></code> will zero out the memory area which could help a lot in
pointer bug detection. Remember that <code class="docutils literal notranslate"><span class="pre">emalloc()</span></code> works basically like the libc <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>: it will look for a big
enough area in different pools, and return you the best fit. So you may be given a recycled pointer which points to
garbage.</p>
<p>Then comes <code class="docutils literal notranslate"><span class="pre">safe_emalloc(size_t</span> <span class="pre">nmemb,</span> <span class="pre">size_t</span> <span class="pre">size,</span> <span class="pre">size_t</span> <span class="pre">offset)</span></code>, which is an <code class="docutils literal notranslate"><span class="pre">emalloc(size</span> <span class="pre">*</span> <span class="pre">nmemb</span> <span class="pre">+</span> <span class="pre">offset)</span></code>
but that does check against overflows for you. You should use this API call if the numbers you must provide come from an
untrusted source, like the userland.</p>
<p>About string facilities, <code class="docutils literal notranslate"><span class="pre">estrdup(char</span> <span class="pre">*)</span></code> and <code class="docutils literal notranslate"><span class="pre">estrndup(char</span> <span class="pre">*,</span> <span class="pre">size_t</span> <span class="pre">len)</span></code> allow to duplicate strings or binary
strings.</p>
<p>Whatever happens, pointers returned by ZendMM must be freed using ZendMM, aka <code class="docutils literal notranslate"><span class="pre">efree()</span></code> call and
<strong>not libc’s free()</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A note on persistent allocations. Persistent allocations stay alive between requests. You traditionnaly use
the common libc <code class="docutils literal notranslate"><span class="pre">malloc/free</span></code> to perform that, but ZendMM has got some shortcuts to libc allocator : the
“persistent” API. This API starts by the <em>“p”</em> letter and let you choose between ZendMM alloc, or persistent
alloc. Hence a <code class="docutils literal notranslate"><span class="pre">pemalloc(size_t,</span> <span class="pre">1)</span></code> is nothing more than a <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, a <code class="docutils literal notranslate"><span class="pre">pefree(void</span> <span class="pre">*,</span> <span class="pre">1)</span></code> is a
<code class="docutils literal notranslate"><span class="pre">free()</span></code> and a <code class="docutils literal notranslate"><span class="pre">pestrdup(void</span> <span class="pre">*,</span> <span class="pre">1)</span></code> is a <code class="docutils literal notranslate"><span class="pre">strdup()</span></code>. Just to say.</p>
</div>
</section>
<section id="zend-memory-manager-debugging-shields">
<h2>Zend Memory Manager debugging shields<a class="headerlink" href="#zend-memory-manager-debugging-shields" title="Link to this heading">¶</a></h2>
<p>ZendMM provides the following abilities:</p>
<ul class="simple">
<li><p>Memory consumption management.</p></li>
<li><p>Memory leak tracking and automatic-free.</p></li>
<li><p>Speed up in allocations by pre-allocating well-known-sized buffers and keeping a warm cache on free</p></li>
</ul>
<section id="memory-consumption-management">
<h3>Memory consumption management<a class="headerlink" href="#memory-consumption-management" title="Link to this heading">¶</a></h3>
<p>ZendMM is the layer behind the PHP userland “memory_limit” feature. Every single byte allocated using the ZendMM layer
is counted and added. When the INI’s <em>memory_limit</em> is reached, you know what happens.
That also mean that any allocation you perform via ZendMM is reflected in the <code class="docutils literal notranslate"><span class="pre">memory_get_usage()</span></code> call from PHP
userland.</p>
<p>As an extension developer, this is a good thing, because it helps mastering the PHP process’ heap size.</p>
<p>If a memory limit error is launched, the engine will bail out from the current code position to a catch block, and will
terminate smoothly. But there is no chance it goes back to the location in your code where the limit blew up.
You must be prepared to that.</p>
<p>That means that in theory, ZendMM cannot return a NULL pointer to you. If the allocation fails from the OS, or if the
allocation generates a memory limit error, the code will run into a catch block and won’t return to you allocation call.</p>
<p>If for any reason you need to bypass that protection, you must then use a traditional libc call, like <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>.
Take care however and know what you do. It may happen that you need to allocate lots of memory and could blow up the PHP
<em>memory_limit</em> if using ZendMM. Thus use another allocator (like libc) but take care: your extension will grow the
current process heap size. That cannot be seen using <code class="docutils literal notranslate"><span class="pre">memory_get_usage()</span></code> in PHP, but by analyzing the current heap
with the OS facilities (like <em>/proc/{pid}/maps</em>)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you need to fully disable ZendMM, you can launch PHP with the <code class="docutils literal notranslate"><span class="pre">USE_ZEND_ALLOC=0</span></code> env var. This way, every
call to the ZendMM API (like <code class="docutils literal notranslate"><span class="pre">emalloc()</span></code>) will be directed to a libc call, and ZendMM will be disabled.
This is especially useful when <a class="reference internal" href="memory_debugging.html"><span class="doc">debugging memory</span></a>.</p>
</div>
</section>
<section id="memory-leak-tracking">
<h3>Memory leak tracking<a class="headerlink" href="#memory-leak-tracking" title="Link to this heading">¶</a></h3>
<p>Remember the main ZendMM rules: it starts when a request starts, it then expects you call its API when in need of
dynamic memory as you are treating a request. When the current request ends, ZendMM shuts down.</p>
<p>By shutting down, it will browse every of its active pointer, and if using
<a class="reference internal" href="../build_system/building_php.html"><span class="doc">a debug build</span></a> of PHP, it will warn you about memory leaking.</p>
<p>Let’s be clear here: if at the end of the current request ZendMM finds some active memory blocks, that means those are
leaking. There should not be any active memory block living onto ZendMM heap at the end of the request, as anyone who
allocated some should have freed them.</p>
<p>If you forget to free blocks, they will all get displayed on <em>stderr</em>. This process of memory leak reporting only works
in the following conditions:</p>
<ul class="simple">
<li><p>You are using <a class="reference internal" href="../build_system/building_php.html"><span class="doc">a debug build</span></a> of PHP</p></li>
<li><p>You have <em>report_memleaks=On</em> in php.ini (default)</p></li>
</ul>
<p>Here is an example of a simple leak into an extension:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PHP_RINIT_FUNCTION</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">emalloc</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When launching PHP with that extension activated, on a debug build, that generates on stderr:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[Fri Jun 9 16:04:59 2017]  Script:  &#39;/tmp/foobar.php&#39;
/path/to/extension/file.c(123) : Freeing 0x00007fffeee65000 (128 bytes), script=/tmp/foobar.php
=== Total 1 memory leaks detected ===
</pre></div>
</div>
<p>Those lines are generated when the Zend Memory Manager shuts down, that is at the end of each treated request.</p>
<p>Beware however:</p>
<ul class="simple">
<li><p>Obviously ZendMM doesn’t know anything about persistent allocations, or allocations that were performed in another way
than using it. Hence, ZendMM can only warn you about allocations it is aware of, every traditional libc allocation
won’t be reported in here, f.e.</p></li>
<li><p>If PHP shuts down in an incorrect maner (what we call an unclean shutdown), ZendMM will report tons of leaks. This is
because when incorrectly shutdown, the engine uses a
<a class="reference external" href="http://man7.org/linux/man-pages/man3/longjmp.3.html">longjmp()</a> call to a catch block, preventing every code that
cleans memory to fire-in. Thus, many leaks get reported. This happens especially after a call to PHP’s exit()/die(),
or if a fatal error gets triggered in some critical parts of PHP.</p></li>
<li><p>If you use a non-debug build of PHP, nothing shows on <em>stderr</em>, ZendMM is dumb but will still clean any allocated
request-bound buffer that’s not been explicitly freed by the programmer</p></li>
</ul>
<p>What you must remember is that ZendMM leak tracking is a nice bonus tool to have, but it does not replace a
<a class="reference internal" href="memory_debugging.html"><span class="doc">true C memory debugger</span></a>.</p>
</section>
</section>
<section id="lifecycle">
<h2>Lifecycle<a class="headerlink" href="#lifecycle" title="Link to this heading">¶</a></h2>
<p>PHP will call the <code class="docutils literal notranslate"><span class="pre">start_memory_manager()</span></code> function during its startup phase, specifically when the PHP process is
started (for instance, when the PHP-FPM service is started, or when a PHP CLI script is run). This will allocate the
heap and the first chunk.</p>
<p>During a request the ZendMM will allocate chunks as needed.</p>
<p>On every request shutdown (during the <code class="docutils literal notranslate"><span class="pre">RSHUTDOWN</span></code> phase), the Zend Engine will call the <code class="docutils literal notranslate"><span class="pre">shutdown_memory_manager()</span></code>
function (which calls the <code class="docutils literal notranslate"><span class="pre">zend_mm_shutdown()</span></code> function) with the boolean argument <code class="docutils literal notranslate"><span class="pre">full</span></code> set to <code class="docutils literal notranslate"><span class="pre">false</span></code>. This
will cleanup for the next request, but not do a full shutdown of the memory manager. For example it will not free the
heap and keep the average amount of chunks used during the current request alive in the <code class="docutils literal notranslate"><span class="pre">cached_chunks</span></code> pointer on the
heap to be reused in the next request.</p>
<p>In the module shutdown phase (<code class="docutils literal notranslate"><span class="pre">MSHUTDOWN</span></code>) the Zend Engine will call the <code class="docutils literal notranslate"><span class="pre">shutdown_memory_manager()</span></code> function (which
calls the <code class="docutils literal notranslate"><span class="pre">zend_mm_shutdown()</span></code> function) with the boolean argument <code class="docutils literal notranslate"><span class="pre">full</span></code> set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, which will trigger a full
shutdown and free all cached chunks as well as the heap itself.</p>
</section>
<section id="zendmm-internal-design">
<h2>ZendMM internal design<a class="headerlink" href="#zendmm-internal-design" title="Link to this heading">¶</a></h2>
<p>The root of the ZendMM is the <code class="docutils literal notranslate"><span class="pre">_zend_mm_heap</span></code> struct (as defined in <a class="reference external" href="https://github.com/php/php-src/blob/c3b910370c5c92007c3e3579024490345cb7f9a7/Zend/zend_alloc.c#L239">Zend/zend_alloc.c</a>) which will be
created for every request during request init and stored in the <code class="docutils literal notranslate"><span class="pre">alloc_globals-&gt;mm_heap</span></code>. This heap also comes with
the first chunk that is allocated with it. Chunks are then subdivided into pages. Smaller allocations are stored in bins
which may fit into one page but some also span multiple pages.</p>
<section id="internal-memory-organisation">
<h3>Internal memory organisation<a class="headerlink" href="#internal-memory-organisation" title="Link to this heading">¶</a></h3>
<section id="heap">
<h4>Heap<a class="headerlink" href="#heap" title="Link to this heading">¶</a></h4>
<p>The heap, as defined in the struct <code class="docutils literal notranslate"><span class="pre">_zend_mm_heap</span></code>, holds links to chunks (<code class="docutils literal notranslate"><span class="pre">main_chunk</span></code> and <code class="docutils literal notranslate"><span class="pre">cached_chunks</span></code>, for
small and large allocations), <code class="docutils literal notranslate"><span class="pre">huge_list</span></code> for huge allocations (&gt;= 2MB) and to bins (for small allocations) in
<code class="docutils literal notranslate"><span class="pre">free_slots[BIN]</span></code>. After initialisation only the <code class="docutils literal notranslate"><span class="pre">main_chunk</span></code> exists and none or some <code class="docutils literal notranslate"><span class="pre">cached_chunks</span></code>.</p>
</section>
<section id="chunks">
<h4>Chunks<a class="headerlink" href="#chunks" title="Link to this heading">¶</a></h4>
<p>Each chunk is 2 MB in size and consists of 512 pages. The first page of every chunk is reserved for the chunk header as
defined in the struct <code class="docutils literal notranslate"><span class="pre">_zend_mm_chunk</span></code> (as defined in <a class="reference external" href="https://github.com/php/php-src/blob/c3b910370c5c92007c3e3579024490345cb7f9a7/Zend/zend_alloc.c#L286">Zend/zend_alloc.c</a>). Chunks are
organised in a linked list with <code class="docutils literal notranslate"><span class="pre">prev</span></code> and <code class="docutils literal notranslate"><span class="pre">next</span></code> pointers.</p>
<p>Each chunk holds a bit mask in <code class="docutils literal notranslate"><span class="pre">free_map</span></code> (512 bits) where a single bit indicates if a page is in use or free.
Information on what is in a page is stored in <code class="docutils literal notranslate"><span class="pre">map</span></code> which is an array of 512 32 bit integers. Each of those integers
is used as a bitmap and holds the meta information about that page.</p>
</section>
<section id="pages">
<h4>Pages<a class="headerlink" href="#pages" title="Link to this heading">¶</a></h4>
<p>A page is 4096 bytes in size and can either hold a bin (for small allocations) or be part of a large allocation. What is
in it can be found in the map of the chunk the page belongs to.</p>
</section>
<section id="bins">
<h4>Bins<a class="headerlink" href="#bins" title="Link to this heading">¶</a></h4>
<p>Small allocations are grouped together in bins. Bin sizes are predefined and come in 30 different sizes (8, 16, 24, 32,
… 3072 bytes). A bin holds same sized values and is linked from the heap directly.</p>
<p>A bin can consist of multiple pages. Example: There exists a bin that holds elements ranging from 257 bytes to 320 bytes
which occupies 5 pages, and therefore has room for 64 (derived from 4096*5/320) elements of that size.</p>
</section>
</section>
<section id="allocation-categories">
<h3>Allocation categories<a class="headerlink" href="#allocation-categories" title="Link to this heading">¶</a></h3>
<section id="small-allocations">
<h4>Small allocations<a class="headerlink" href="#small-allocations" title="Link to this heading">¶</a></h4>
<p>Allocations less or equal than 3072 bytes are organised in bins.</p>
<p>If a bin is already initialised, the <code class="docutils literal notranslate"><span class="pre">free_slot</span></code> pointer on the <code class="docutils literal notranslate"><span class="pre">zend_mm_heap</span></code> struct is the address to be used
(this address will be returned by the call to <code class="docutils literal notranslate"><span class="pre">emalloc()</span></code> and will be incremented to point to the next free slot, see
implementation in <code class="docutils literal notranslate"><span class="pre">zend_mm_alloc_small</span></code>).</p>
<p>If the bin for this specific size is not initialised already, it will be created in the <code class="docutils literal notranslate"><span class="pre">zend_mm_alloc_small_slow</span></code>
function and a pointer to the first element of the bin is returned.</p>
</section>
<section id="large-allocations">
<h4>Large allocations<a class="headerlink" href="#large-allocations" title="Link to this heading">¶</a></h4>
<p>Allocations bigger than 3072 bytes, but small enough to fit in a chunk (2 MB chunk size - 4096 bytes chunk header (first
page) makes 2093056 bytes) are directly stored in the pages. The first page will be marked <code class="docutils literal notranslate"><span class="pre">LRUN</span></code> in the map of the
chunk and also hold the number of allocated pages.</p>
</section>
<section id="huge-allocations">
<h4>Huge allocations<a class="headerlink" href="#huge-allocations" title="Link to this heading">¶</a></h4>
<p>If an allocation is larger than the chunk size minus one page (2 MB chunk size - 4096 bytes chunk header (first page)
makes 2093056 bytes) the memory is allocated using <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> and put on the <code class="docutils literal notranslate"><span class="pre">huge_list</span></code> linked list on the heap.</p>
</section>
</section>
</section>
<section id="hooking-into-the-zendmm">
<h2>Hooking into the ZendMM<a class="headerlink" href="#hooking-into-the-zendmm" title="Link to this heading">¶</a></h2>
<p>You can call the <code class="docutils literal notranslate"><span class="pre">zend_mm_set_custom_handlers()</span></code> function and give it pointers to your <code class="docutils literal notranslate"><span class="pre">malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">free</span></code> and
<code class="docutils literal notranslate"><span class="pre">realloc</span></code> handlers as well as your custom heap or the current heap that you may fetch via <code class="docutils literal notranslate"><span class="pre">zend_mm_get_heap()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">my_malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">my_realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">PHP_MINIT_FUNCTION</span><span class="p">(</span><span class="n">my_extension</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">zend_mm_set_custom_handlers</span><span class="p">(</span>
<span class="w">        </span><span class="n">zend_mm_get_heap</span><span class="p">(),</span>
<span class="w">        </span><span class="n">my_malloc</span><span class="p">,</span>
<span class="w">        </span><span class="n">my_free</span><span class="p">,</span>
<span class="w">        </span><span class="n">my_realloc</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may also bring your own heap and inject it via <code class="docutils literal notranslate"><span class="pre">zend_mm_set_heap()</span></code> which returns a pointer to the current (or
old) heap. Beware that on a heap with custom handlers, ZendMM’s behaviour will be different:</p>
<ul class="simple">
<li><p>ZendMM will not run cleanup during <code class="docutils literal notranslate"><span class="pre">zend_mm_shutdown()</span></code> (which is called during PHP request shutdown phase), leaving
you with a memory leak if your custom handlers just forward calls to the ZendMM internal functions.</p></li>
<li><p>ZendMM’s garbage collector implemented in <code class="docutils literal notranslate"><span class="pre">zend_mm_gc()</span></code> will not be doing anything. This also means it will not try
to free chunks in case you reach the memory limit during an allocation in one of the ZendMM internal functions.</p></li>
<li><p>The only way to detect that a full shutdown is in progress in your heap with custom handlers is that your <code class="docutils literal notranslate"><span class="pre">free</span></code>
function will be called with the address of your heap.</p></li>
<li><p>There is no chance of knowing when <code class="docutils literal notranslate"><span class="pre">zend_mm_shutdown()</span></code> will perform a request shutdown.</p></li>
</ul>
</section>
<section id="common-errors-and-mistakes">
<h2>Common errors and mistakes<a class="headerlink" href="#common-errors-and-mistakes" title="Link to this heading">¶</a></h2>
<p>Here are the most common errors while using ZendMM, and what you should do about them.</p>
<ol class="arabic simple">
<li><p>Usage of ZendMM as you are not treating a request.</p></li>
</ol>
<p>Get infos about
<a class="reference internal" href="../extensions_design/php_lifecycle.html"><span class="doc">the PHP lifecycle</span></a> to know in your extensions when you are treating a
request, and when not. If you use ZendMM out of the scope of a request (like in <code class="docutils literal notranslate"><span class="pre">MINIT()</span></code>), the allocation will be
silently cleared by ZendMM before treating the first request, and you’ll probably use-after-free : simply don’t.</p>
<ol class="arabic simple" start="2">
<li><p>Buffer overflow and underflows.</p></li>
</ol>
<p>Use a <a class="reference internal" href="memory_debugging.html"><span class="doc">memory debugger</span></a>. If you write below or past a memory area returned by ZendMM, you will
overwrite crucial ZendMM structures and trigger a crash. It may happen that the <em>“zend_mm_heap corrupted”</em> message gets
display in case ZendMM was able to detect the mess for you. The stack trace will show a crash from some code, to some
ZendMM code. ZendMM code does not crash itself. If you get crashed in the middle of ZendMM code, that highly probably
means you messed up with a pointer somewhere. Kick in your favorite memory debugger and look for the guilty part and
fix it.</p>
<ol class="arabic simple" start="3">
<li><p>Mix API calls</p></li>
</ol>
<p>If you allocate a ZendMM pointer (<code class="docutils literal notranslate"><span class="pre">emalloc()</span></code> f.e) and free it using libc (<code class="docutils literal notranslate"><span class="pre">free()</span></code>), or the opposite scenario:
you will crash. Be rigorous. Also if you pass to ZendMM’s <code class="docutils literal notranslate"><span class="pre">efree()</span></code> any pointer it doesn’t know about: you will crash.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="memory_debugging.html">Debugging memory</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>