<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Zend Memory Manager &mdash; PHP Internals Book</title>
    
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PHP Internals Book" href="../../index.html" />
    <link rel="up" title="Memory management" href="../memory_management.html" />
    <link rel="next" title="Debugging memory" href="memory_debugging.html" />
    <link rel="prev" title="Memory management" href="../memory_management.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Zend Memory Manager</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="../memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="memory_debugging.html">Debugging memory</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="zend-memory-manager">
<h1>Zend Memory Manager<a class="headerlink" href="#zend-memory-manager" title="Permalink to this headline">¶</a></h1>
<p>Zend Memory Manager, often abbreviated as <em>ZendMM</em> or <em>ZMM</em>, is a C layer that aims to provide abilities to allocate
and release dynamic <strong>request-bound</strong> memory.</p>
<p>Note the &#8220;request-bound&#8221; in the above sentence.</p>
<p>ZendMM is not just a classical layer over libc&#8217;s dynamic memory allocator, mainly represented by the couple API calls
<tt class="docutils literal"><span class="pre">malloc()/free()</span></tt>. ZendMM is about request-bound memory that PHP must allocate while treating a request.</p>
<div class="section" id="the-two-main-kind-of-dynamic-memory-pools-in-php">
<h2>The two main kind of dynamic memory pools in PHP<a class="headerlink" href="#the-two-main-kind-of-dynamic-memory-pools-in-php" title="Permalink to this headline">¶</a></h2>
<p>PHP is a share-nothing architecture. Well, not at 100%. Let us explain.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You may need to read <a class="reference internal" href="../extensions_design/php_lifecycle.html"><em>the PHP lifecycle chapter</em></a> before continuing
here, you&#8217;ll get additionnal informations about the different steps and cycles that can be drawn from PHP
lifetime.</p>
</div>
<p>PHP can treat several hundreds or thousands of requests into the same process. By default, PHP will forget anything it
knows of the current request, when that later finishes.</p>
<p>&#8220;Forgetting&#8221; things translates to freeing any dynamic buffer that got allocated while treating a request. That means
that when in the process of treating a request, one must not allocate dynamic memory using traditionnal libc calls.
Doing that is perfectly valid, but you give a chance to forget to free such a buffer.</p>
<p>ZendMM comes with an API that substitute to libc&#8217;s dynamic allocator, by copying its API. When in the process of
treating a request, the programmer must use that API instead of libc&#8217;s allocator.</p>
<p>For example, when PHP treats a request, it will parse PHP files. Those ones will lead to functions and classes
declarations, for example. When the compiler comes to compile the PHP files, it will allocate some dynamic memory to
store classes and functions it discovers. But, at the end of the request, PHP will forget about those latter. By
default, PHP forgets <em>a very huge number</em> of informations from one request to another.</p>
<p>There exists however some pretty rare informations you need to persist across several requests. But that&#8217;s uncommon.</p>
<p>What could be kept unchanged through requests ? What we call <strong>persistent</strong> objects. Once more let us insist : those
are rare cases. For example, the current PHP executable path won&#8217;t change from requests to requests. That latter
information is allocated permanently, that means it is allocated with a traditionnal libc&#8217;s <tt class="docutils literal"><span class="pre">malloc()</span></tt> call.</p>
<p>What else? Some strings. For example, the <em>&#8220;_SERVER&#8221;</em> string will be reused from request to request, as every request
will create the <tt class="docutils literal"><span class="pre">$_SERVER</span></tt> PHP array. So the <em>&#8220;_SERVER&#8221;</em> string itself can be permanently allocated, because it will
be allocated once.</p>
<p>What you must remember:</p>
<ul>
<li><dl class="first docutils">
<dt>There exists two kinds of dynamic memory allocations while programming PHP Core or extensions:</dt>
<dd><ul class="first last simple">
<li>Request-bound dynamic allocations.</li>
<li>Permanent dynamic allocations.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Request-bound dynamic memory allocations</dt>
<dd><ul class="first last simple">
<li>Must only be performed when PHP is treating a request (not before, nor after).</li>
<li>Should only be performed using the ZendMM dynamic memory allocation API.</li>
<li>Are very common in extensions design, basically 95% of your dynamic allocations will be request-bound.</li>
<li>Are tracked by ZendMM, and you&#8217;ll be informed about leaking.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Permanent dynamic memory allocations</dt>
<dd><ul class="first last simple">
<li>Should not be performed while PHP is treating a request (not forbidden, but a bad idea).</li>
<li>Are not tracked by ZendMM, and you won&#8217;t be informed about leaking.</li>
<li>Should be pretty rare in an extension.</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Also, keep in mind that all PHP source code has been based on such a memory level. Thus, many internal structures get
allocated using the Zend Memory Manager. Most of them got a &#8220;persistent&#8221; API call, which when used, lead to
traditionnal libc allocation.</p>
<p>Here is a request-bound allocated <a class="reference internal" href="../internal_types/strings/zend_strings.html"><em>zend_string</em></a>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>And here is the persistent allocated one:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Same for <a class="reference internal" href="../internal_types/hashtables.html"><em>HashTable</em></a>. Request-bound allocated one:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_array</span> <span class="n">ar</span><span class="p">;</span>
<span class="n">zend_hash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Persistent allocated one:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_array</span> <span class="n">ar</span><span class="p">;</span>
<span class="n">zend_hash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>It is always the same in all the different Zend APIs. Usually, it is whether a <em>&#8220;0&#8221;</em> to pass as last parameter to mean
&#8220;I want this structure to be allocated using ZendMM, so request-bound&#8221;, or <em>&#8220;1&#8221;</em> meaning &#8220;I want this structure to get
allocated bypassing ZendMM and using a traditionnal libc&#8217;s <tt class="docutils literal"><span class="pre">malloc()</span></tt> call&#8221;.</p>
<p>Obviously, those structures provide an API that remembers how it did allocate the structure, to use the right
deallocation function when destroyed. Hence in such a code:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">zend_hash_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ar</span><span class="p">);</span>
</pre></div>
</div>
<p>The API knows whether those structures were allocated using request-bound allocation, or permanent one, and in the
first case will use <tt class="docutils literal"><span class="pre">efree()</span></tt> to release it, and in the second case libc&#8217;s <tt class="docutils literal"><span class="pre">free()</span></tt>.</p>
</div>
<div class="section" id="zend-memory-manager-api">
<h2>Zend Memory Manager API<a class="headerlink" href="#zend-memory-manager-api" title="Permalink to this headline">¶</a></h2>
<p>The API is located into
<a class="reference external" href="https://github.com/php/php-src/blob/c3b910370c5c92007c3e3579024490345cb7f9a7/Zend/zend_alloc.h">Zend/zend_alloc.h</a></p>
<p>The API calls are mainly C macros and not functions, so get prepared if you debug them and want to look at how they
work. Those calls copy libc&#8217;s calls, they usually add an &#8220;e&#8221; in the function name; So you should not be lost, and there
is not many things to detail about the API.</p>
<p>Basically what you&#8217;ll use most are <tt class="docutils literal"><span class="pre">emalloc(size_t)</span></tt> and <tt class="docutils literal"><span class="pre">efree(void</span> <span class="pre">*)</span></tt>.</p>
<p>You are also provided with <tt class="docutils literal"><span class="pre">ecalloc(size_t</span> <span class="pre">nmemb,</span> <span class="pre">size_t</span> <span class="pre">size)</span></tt> that allocates <tt class="docutils literal"><span class="pre">nmemb</span></tt> of individual size <tt class="docutils literal"><span class="pre">size</span></tt>,
and zeroes the area. If you are a strong C programmer with experience, you should know that whenever possible, it is
better to use <tt class="docutils literal"><span class="pre">ecalloc()</span></tt> over <tt class="docutils literal"><span class="pre">emalloc()</span></tt> as <tt class="docutils literal"><span class="pre">ecalloc()</span></tt> will zero out the memory area which could help a lot in
pointer bug detection. Remember that <tt class="docutils literal"><span class="pre">emalloc()</span></tt> works basically like the libc <tt class="docutils literal"><span class="pre">malloc()</span></tt>: it will look for a big
enough area in different pools, and return you the best fit. So you may be given a recycled pointer which points to
garbage.</p>
<p>Then comes <tt class="docutils literal"><span class="pre">safe_emalloc(size_t</span> <span class="pre">nmemb,</span> <span class="pre">size_t</span> <span class="pre">size,</span> <span class="pre">size_t</span> <span class="pre">offset)</span></tt>, which is an <tt class="docutils literal"><span class="pre">emalloc(size</span> <span class="pre">*</span> <span class="pre">nmemb</span> <span class="pre">+</span> <span class="pre">offset)</span></tt>
but that does check against overflows for you. You should use this API call if the numbers you must provide come from an
untrusted source, like the userland.</p>
<p>About string facilities, <tt class="docutils literal"><span class="pre">estrdup(char</span> <span class="pre">*)</span></tt> and <tt class="docutils literal"><span class="pre">estrndup(char</span> <span class="pre">*,</span> <span class="pre">size_t</span> <span class="pre">len)</span></tt> allow to duplicate strings or binary
strings.</p>
<p>Whatever happens, pointers returned by ZendMM must be freed using ZendMM, aka <tt class="docutils literal"><span class="pre">efree()</span></tt> call and
<strong>not libc&#8217;s free()</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A note on persistent allocations. Persistent allocations stay alive between requests. You traditionnaly use
the common libc <tt class="docutils literal"><span class="pre">malloc/free</span></tt> to perform that, but ZendMM has got some shortcuts to libc allocator : the
&#8220;persistent&#8221; API. This API starts by the <em>&#8220;p&#8221;</em> letter and let you choose between ZendMM alloc, or persistent
alloc. Hence a <tt class="docutils literal"><span class="pre">pemalloc(size_t,</span> <span class="pre">1)</span></tt> is nothing more than a <tt class="docutils literal"><span class="pre">malloc()</span></tt>, a <tt class="docutils literal"><span class="pre">pefree(void</span> <span class="pre">*,</span> <span class="pre">1)</span></tt> is a
<tt class="docutils literal"><span class="pre">free()</span></tt> and a <tt class="docutils literal"><span class="pre">pestrdup(void</span> <span class="pre">*,</span> <span class="pre">1)</span></tt> is a <tt class="docutils literal"><span class="pre">strdup()</span></tt>. Just to say.</p>
</div>
</div>
<div class="section" id="zend-memory-manager-debugging-shields">
<h2>Zend Memory Manager debugging shields<a class="headerlink" href="#zend-memory-manager-debugging-shields" title="Permalink to this headline">¶</a></h2>
<p>ZendMM provides the following abilities:</p>
<ul class="simple">
<li>Memory consumption management.</li>
<li>Memory leak tracking and automatic-free.</li>
<li>Speed up in allocations by pre-allocating well-known-sized buffers and keeping a warm cache on free</li>
</ul>
<div class="section" id="memory-consumption-management">
<h3>Memory consumption management<a class="headerlink" href="#memory-consumption-management" title="Permalink to this headline">¶</a></h3>
<p>ZendMM is the layer behind the PHP userland &#8220;memory_limit&#8221; feature. Every single byte allocated using the ZendMM layer
is counted and added. When the INI&#8217;s <em>memory_limit</em> is reached, you know what happens.
That also mean that any allocation you perform via ZendMM is reflected in the <tt class="docutils literal"><span class="pre">memory_get_usage()</span></tt> call from PHP
userland.</p>
<p>As an extension developper, this is a good thing, because it helps mastering the PHP process&#8217; heap size.</p>
<p>If a memory limit error is launched, the engine will bail out from the current code position to a catch block, and will
terminate smoothly. But there is no chance it goes back to the location in your code where the limit blew up.
You must be prepared to that.</p>
<p>That means that in theory, ZendMM cannot return a NULL pointer to you. If the allocation fails from the OS, or if the
allocation generates a memory limit error, the code will run into a catch block and won&#8217;t return to you allocation call.</p>
<p>If for any reason you need to bypass that protection, you must then use a traditionnal libc call, like <tt class="docutils literal"><span class="pre">malloc()</span></tt>.
Take care however and know what you do. It may happen that you need to allocate lots of memory and could blow up the PHP
<em>memory_limit</em> if using ZendMM. Thus use another allocator (like libc) but take care: your extension will grow the
current process heap size. That cannot be seen using <tt class="docutils literal"><span class="pre">memory_get_usage()</span></tt> in PHP, but by analyzing the current heap
with the OS facilities (like <em>/proc/{pid}/maps</em>)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need to fully disable ZendMM, you can launch PHP with the <tt class="docutils literal"><span class="pre">USE_ZEND_ALLOC=0</span></tt> env var. This way, every
call to the ZendMM API (like <tt class="docutils literal"><span class="pre">emalloc()</span></tt>) will be directed to a libc call, and ZendMM will be disabled.
This is especially useful when <a class="reference internal" href="memory_debugging.html"><em>debugging memory</em></a>.</p>
</div>
</div>
<div class="section" id="memory-leak-tracking">
<h3>Memory leak tracking<a class="headerlink" href="#memory-leak-tracking" title="Permalink to this headline">¶</a></h3>
<p>Remember the main ZendMM rules: it starts when a request starts, it then expects you call its API when in need of
dynamic memory as you are treating a request. When the current request ends, ZendMM shuts down.</p>
<p>By shutting down, it will browse every of its active pointer, and if using
<a class="reference internal" href="../build_system/building_php.html"><em>a debug build</em></a> of PHP, it will warn you about memory leaking.</p>
<p>Let&#8217;s be clear here: if at the end of the current request ZendMM finds some active memory blocks, that means those are
leaking. There should not be any active memory block living onto ZendMM heap at the end of the request, as anyone who
allocated some should have freed them.</p>
<p>If you forget to free blocks, they will all get displayed on <em>stderr</em>. This process of memory leak reporting only works
in the following conditions:</p>
<ul class="simple">
<li>You are using <a class="reference internal" href="../build_system/building_php.html"><em>a debug build</em></a> of PHP</li>
<li>You have <em>report_memleaks=On</em> in php.ini (default)</li>
</ul>
<p>Here is an example of a simple leak into an extension:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PHP_RINIT_FUNCTION</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="n">emalloc</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When launching PHP with that extension activated, on a debug build, that generates on stderr:</p>
<div class="highlight-c"><div class="highlight"><pre>[Fri Jun 9 16:04:59 2017]  Script:  &#39;/tmp/foobar.php&#39;
/path/to/extension/file.c(123) : Freeing 0x00007fffeee65000 (128 bytes), script=/tmp/foobar.php
=== Total 1 memory leaks detected ===
</pre></div>
</div>
<p>Those lines are generated when the Zend Memory Manager shuts down, that is at the end of each treated request.</p>
<p>Beware however:</p>
<ul class="simple">
<li>Obviously ZendMM doesn&#8217;t know anything about persistent allocations, or allocations that were performed in another way
than using it. Hence, ZendMM can only warn you about allocations it is aware of, every traditionnal libc allocation
won&#8217;t be reported in here, f.e.</li>
<li>If PHP shuts down in an incorrect maner (what we call an unclean shutdown), ZendMM will report tons of leaks. This is
because when incorrectly shutdown, the engine uses a
<a class="reference external" href="http://man7.org/linux/man-pages/man3/longjmp.3.html">longjmp()</a> call to a catch block, preventing every code that
cleans memory to fire-in. Thus, many leaks get reported. This happens especially after a call to PHP&#8217;s exit()/die(),
or if a fatal error gets triggered in some critical parts of PHP.</li>
<li>If you use a non-debug build of PHP, nothing shows on <em>stderr</em>, ZendMM is dumb but will still clean any allocated
request-bound buffer that&#8217;s not been explicitely freed by the programmer</li>
</ul>
<p>What you must remember is that ZendMM leak tracking is a nice bonus tool to have, but it does not replace a
<a class="reference internal" href="memory_debugging.html"><em>true C memory debugger</em></a>.</p>
</div>
</div>
<div class="section" id="zendmm-internal-design">
<h2>ZendMM internal design<a class="headerlink" href="#zendmm-internal-design" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="common-errors-and-mistakes">
<h2>Common errors and mistakes<a class="headerlink" href="#common-errors-and-mistakes" title="Permalink to this headline">¶</a></h2>
<p>Here are the most common errors while using ZendMM, and what you should do about them.</p>
<ol class="arabic simple">
<li>Usage of ZendMM as you are not treating a request.</li>
</ol>
<p>Get infos about
<a class="reference internal" href="../extensions_design/php_lifecycle.html"><em>the PHP lifecycle</em></a> to know in your extensions when you are treating a
request, and when not. If you use ZendMM out of the scope of a request (like in <tt class="docutils literal"><span class="pre">MINIT()</span></tt>), the allocation will be
silently cleared by ZendMM before treating the first request, and you&#8217;ll probably use-after-free : simply don&#8217;t.</p>
<ol class="arabic simple" start="2">
<li>Buffer overflow and underflows.</li>
</ol>
<p>Use a <a class="reference internal" href="memory_debugging.html"><em>memory debugger</em></a>. If you write bellow or past a memory area returned by ZendMM, you will
overwrite crucial ZendMM structures and trigger a crash. It may happen that the <em>&#8220;zend_mm_heap corrupted&#8221;</em> message gets
display in case ZendMM was able to detect the mess for you. The stack trace will show a crash from some code, to some
ZendMM code. ZendMM code does not crash itself. If you get crashed in the middle of ZendMM code, that highly probably
means you messed up with a pointer somewhere. Kick in your favorite memory debugger and look for the guilty part and
fix it.</p>
<ol class="arabic simple" start="3">
<li>Mix API calls</li>
</ol>
<p>If you allocate a ZendMM pointer (<tt class="docutils literal"><span class="pre">emalloc()</span></tt> f.e) and free it using libc (<tt class="docutils literal"><span class="pre">free()</span></tt>), or the opposite scenario:
you will crash. Be rigorous. Also if you pass to ZendMM&#8217;s <tt class="docutils literal"><span class="pre">efree()</span></tt> any pointer it doesn&#8217;t know about: you will crash.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="../memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="memory_debugging.html">Debugging memory</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>