<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PHP’s custom printf functions &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../../_static/style.css?v=38da9290" />
    <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="The Resource type: zend_resource" href="../zend_resources.html" />
    <link rel="prev" title="smart_str API" href="smart_str.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>PHP’s custom printf functions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="smart_str.html">smart_str API</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../zend_resources.html">The Resource type: zend_resource</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="php-s-custom-printf-functions">
<h1>PHP’s custom printf functions<a class="headerlink" href="#php-s-custom-printf-functions" title="Link to this heading">¶</a></h1>
<p>You all know libc’s <code class="docutils literal notranslate"><span class="pre">printf()</span></code> and family. This chapter will detail those many clones PHP declares and use, what’s
their goal, why use them and when to use them.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Libc’s documentation about <code class="docutils literal notranslate"><span class="pre">printf()</span></code> and friends
<a class="reference external" href="https://www.gnu.org/software/libc/manual/html_node/Formatted-Output-Functions.html">is located here</a></p>
</div>
<p>You know that those functions are useful, but sometimes don’t provide enough functionalities.
Also, you know that
<a class="reference external" href="https://www.gnu.org/software/libc/manual/html_node/Customizing-Printf.html">adding format strings</a> to <code class="docutils literal notranslate"><span class="pre">printf()</span></code>
family is not trivial, not portable and security risky.</p>
<p>PHP adds its own printf-like functions to replace libc ones and to be used by the internal developer.
They will mainly add new formats, play with <a class="reference internal" href="zend_strings.html"><span class="doc">zend_string</span></a> instead of
<code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>, etc…  Let’s see them together.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You must master your libc default <code class="docutils literal notranslate"><span class="pre">printf()</span></code> formats. Read
<a class="reference external" href="http://www.cplusplus.com/reference/cstdio/printf/">their documentation here</a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Those functions are added <strong>to replace</strong> libc ones, that means that if you use <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code> f.e, that won’t
lead to libc’s <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code>, but to PHP replacement. Except the traditional <code class="docutils literal notranslate"><span class="pre">printf()</span></code>, everything else
is replaced.</p>
</div>
<section id="traditional-use">
<h2>Traditional use<a class="headerlink" href="#traditional-use" title="Link to this heading">¶</a></h2>
<p>First of all, you should not use <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code>, as that function doesn’t perform any check and allows many buffer
overflow errors. Please, try to avoid using it.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please try to avoid using <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code> as much as possible.</p>
</div>
<p>Then, you have some choice.</p>
<section id="you-know-your-result-buffer-size">
<h3>You know your result buffer size<a class="headerlink" href="#you-know-your-result-buffer-size" title="Link to this heading">¶</a></h3>
<p>If you know your buffer size, <code class="docutils literal notranslate"><span class="pre">snprintf()</span></code> or <code class="docutils literal notranslate"><span class="pre">slprintf()</span></code> will do the job for you. There is a difference in what
those functions return, but not in what those functions do.</p>
<p>They both print according to the formats passed, and they both terminate your buffer by a <code class="docutils literal notranslate"><span class="pre">NUL</span></code> byte <em>‘\0’</em> whatever
happens. However, <code class="docutils literal notranslate"><span class="pre">snprintf()</span></code> returns the number of characters that could have been used, whereas <code class="docutils literal notranslate"><span class="pre">slprintf()</span></code>
returns the number of characters that have effectively been used, thus enabling to detect too-small buffers and string
truncation. This, is not counting the final <em>‘\0’</em>.</p>
<p>Here is an example so that you fully understand:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"> </span><span class="cm">/* 8-char large buffer */</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">str</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello world&quot;</span><span class="p">;</span><span class="w"> </span><span class="cm">/* 12 chars including \0 in count */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>

<span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">snprintf</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
<span class="cm">/* r = 11 here even if only 7 printable chars were written in foo */</span>

<span class="cm">/* foo value is now &#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39; &#39; &#39;w&#39; &#39;\0&#39; */</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">snprintf()</span></code> is not a good function to use, as it does not allows to detect an eventual string truncation.
As you can see from the example above, “Hello world\0” doesn’t fit in an eight-byte buffer, that’s obvious, but
<code class="docutils literal notranslate"><span class="pre">snprintf()</span></code> still returns you 11, which is <code class="docutils literal notranslate"><span class="pre">strlen(&quot;Hello</span> <span class="pre">world\0&quot;)</span></code>. You have no way to detect that the string’s
got truncated.</p>
<p>Here is <code class="docutils literal notranslate"><span class="pre">slprintf()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"> </span><span class="cm">/* 8-char large buffer */</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">str</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello world&quot;</span><span class="p">;</span><span class="w"> </span><span class="cm">/* 12 chars including \0 in count */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>

<span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slprintf</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
<span class="cm">/* r = 7 here , because 7 printable chars were written in foo */</span>

<span class="cm">/* foo value is now &#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39; &#39; &#39;w&#39; &#39;\0&#39; */</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">slprintf()</span></code>, the result buffer <code class="docutils literal notranslate"><span class="pre">foo</span></code> contains the exact same string, but the returned value is now 7. 7 is
less than the 11 chars from the <em>“Hello world”</em> string, thus you can detect that it got truncated:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slprintf</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* A string truncation occurred */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Remember:</p>
<ul class="simple">
<li><p>Those two function always <code class="docutils literal notranslate"><span class="pre">NUL</span></code> terminate the string, truncation or not. Result strings are then safe C strings.</p></li>
<li><p>Only <code class="docutils literal notranslate"><span class="pre">slprintf()</span></code> allows to detect a string truncation.</p></li>
</ul>
<p>Those two functions are defined in
<a class="reference external" href="https://github.com/php/php-src/blob/648be8600ff89e1b0e4a4ad25cebad42b53bed6d/main/snprintf.c">main/snprintf.c</a></p>
</section>
<section id="you-don-t-know-your-buffer-size">
<h3>You don’t know your buffer size<a class="headerlink" href="#you-don-t-know-your-buffer-size" title="Link to this heading">¶</a></h3>
<p>Now if you don’t know your result buffer size, you need a dynamically allocated one, and then you’ll use <code class="docutils literal notranslate"><span class="pre">spprintf()</span></code>.
Remember that <strong>you’ll have to free</strong> the buffer by yourself !</p>
<p>Here is an example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>

<span class="kt">time_t</span><span class="w"> </span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Here is the date: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">asctime</span><span class="p">(</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timestamp</span><span class="p">)));</span>

<span class="cm">/* now use result that contains something like &quot;Here is the date: Thu Jun 15 19:12:51 2017\n&quot; */</span>

<span class="n">efree</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">spprintf()</span></code> returns the number of characters that’ve been printed into the result buffer, not counting the final
<em>‘\0’</em>, hence you know the number of bytes that got allocated for you (minus one).</p>
<p>Please, note that the allocation is done using ZendMM (request allocation), and should thus be used as part of a
request and freed using <code class="docutils literal notranslate"><span class="pre">efree()</span></code> and not <code class="docutils literal notranslate"><span class="pre">free()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../../memory_management/zend_memory_manager.html"><span class="doc">The chapter about Zend Memory Manager</span></a> (ZendMM) details
how dynamic memory is allocated through PHP.</p>
</div>
<p>If you want to limit the buffer size, you pass that limit as the second argument, if you pass <em>0</em>, that means
unlimited:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>

<span class="kt">time_t</span><span class="w"> </span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* Do not print more than 10 bytes || allocate more than 11 bytes */</span>
<span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Here is the date: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">asctime</span><span class="p">(</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timestamp</span><span class="p">)));</span>

<span class="cm">/* r == 10 here, and 11 bytes were allocated into result */</span>

<span class="n">efree</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Whenever possible, try not to use dynamic memory allocations. That impacts performances. If you got the
choice, go for the static stack allocated buffer.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">spprintf()</span></code> is written in
<a class="reference external" href="https://github.com/php/php-src/blob/648be8600ff89e1b0e4a4ad25cebad42b53bed6d/main/spprintf.c">main/spprintf.c</a>.</p>
</section>
<section id="what-about-printf">
<h3>What about printf() ?<a class="headerlink" href="#what-about-printf" title="Link to this heading">¶</a></h3>
<p>If you need to <code class="docutils literal notranslate"><span class="pre">printf()</span></code>, aka to print formatted to the output stream, use <code class="docutils literal notranslate"><span class="pre">php_printf()</span></code>. That function
internally uses <code class="docutils literal notranslate"><span class="pre">spprintf()</span></code>, and thus performs a dynamic allocation that it frees itself just after having sent it
to the SAPI output, aka stdout in case of CLI, or the output buffer (CGI buffer f.e) for other SAPIs.</p>
</section>
<section id="special-php-printf-formats">
<h3>Special PHP printf formats<a class="headerlink" href="#special-php-printf-formats" title="Link to this heading">¶</a></h3>
<p>Remember that PHP replaces most libc’s <code class="docutils literal notranslate"><span class="pre">printf()</span></code> functions by its own of its own design. You can have a look at
the argument parsing API which is easy to understand <a class="reference external" href="https://github.com/php/php-src/blob/509f5097ab0b578adc311c720afcea8de266aadd/main/spprintf.c#L203">from reading the source</a>.</p>
<p>What that means is that arguments parsing algo has been fully rewritten, and may differ from what you’re used to in libc.
F.e, the libc locale is not taken care of in most cases.</p>
<p>Special formats may be used, like <em>“%I64”</em> to explicitly print to an int64, or <em>“%I32”</em>.
You can also use <em>“%Z”</em> to make a zval printable (according to PHP cast rules to string), that one is a great addition.</p>
<p>The formatter will also recognize infinite numbers and print “INF”, or “NAN” for not-a-number.</p>
<p>If you make a mistake, and ask the formatter to print a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer, where libc will crash for sure, PHP will
return <em>“(null)”</em> as a result string.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If in a printf you see a magic <em>“(null)”</em> appearing, that means you passed a NULL pointer to one of PHP
printf family functions.</p>
</div>
</section>
<section id="printf-ing-into-zend-strings">
<h3>Printf()ing into zend_strings<a class="headerlink" href="#printf-ing-into-zend-strings" title="Link to this heading">¶</a></h3>
<p>As <a class="reference internal" href="zend_strings.html"><span class="doc">zend_string</span></a> are a very common structure into PHP source, you may need to <code class="docutils literal notranslate"><span class="pre">printf()</span></code> into a
<code class="docutils literal notranslate"><span class="pre">zend_string</span></code> instead of a traditional C <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.  For this, use <code class="docutils literal notranslate"><span class="pre">strpprintf()</span></code>.</p>
<p>The API is <code class="docutils literal notranslate"><span class="pre">zend_string</span> <span class="pre">*strpprintf(size_t</span> <span class="pre">max_len,</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*format,</span> <span class="pre">...)</span></code> that means that the <code class="docutils literal notranslate"><span class="pre">zend_string</span></code> is
returned to you, and not the number of printed chars as you may expect. You can limit that number though, using the
first parameter (pass 0 to mean infinite); and you must remember that the <code class="docutils literal notranslate"><span class="pre">zend_string</span></code> will be allocated using the
Zend Memory Manager, and thus bound to the current request.</p>
<p>Obviously, the format API is shared with the one seen above.</p>
<p>Here is a quick example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_string</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">;</span>

<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strpprintf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;You are using PHP %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PHP_VERSION</span><span class="p">);</span>

<span class="cm">/* Do something with result */</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="a-note-on-zend-api">
<h3>A note on <code class="docutils literal notranslate"><span class="pre">zend_</span></code> API<a class="headerlink" href="#a-note-on-zend-api" title="Link to this heading">¶</a></h3>
<p>You may meet <code class="docutils literal notranslate"><span class="pre">zend_spprintf()</span></code>, or <code class="docutils literal notranslate"><span class="pre">zend_strpprintf()</span></code> functions. Those are the exact same as the ones seen above.</p>
<p>They are just here as part of the separation between the Zend Engine and PHP Core, a detail that is not important for
us, as into the source code, everything gets mixed together.</p>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="smart_str.html">smart_str API</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../zend_resources.html">The Resource type: zend_resource</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>