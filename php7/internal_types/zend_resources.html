<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>The Resource type: zend_resource &#8212; PHP Internals Book</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=38da9290" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="HashTables: zend_array" href="hashtables.html" />
    <link rel="prev" title="PHP’s custom printf functions" href="strings/printing_functions.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>The Resource type: zend_resource</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="strings/printing_functions.html">PHP’s custom printf functions</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="hashtables.html">HashTables: zend_array</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="the-resource-type-zend-resource">
<h1>The Resource type: zend_resource<a class="headerlink" href="#the-resource-type-zend-resource" title="Link to this heading">¶</a></h1>
<p>Even though PHP could really get rid of the “resource” type, because custom object storage allows to build a PHP
representation of any abstract kind of data, that resource type still exists in the current version of PHP, and you may
need to deal with it.</p>
<p>If you need to create resources, we really would like to push you not to, but instead use objects and their
custom storage management. Objects is the PHP type that can embed
anything of any type. However, for historical reasons, PHP still knows about that special type “Resource”, and still
makes use of it in its heart or in some extensions. Let’s see that type together. Beware however, it is really cryptic
and suffers from a long past history, so don’t be surprised about its design especially when reading the source code
about it</p>
<section id="what-is-the-resource-type">
<h2>What is the “Resource” type?<a class="headerlink" href="#what-is-the-resource-type" title="Link to this heading">¶</a></h2>
<p>Easy enough you know about it. We are talking about this here:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$fp</span> <span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;/proc/cpuinfo&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">);</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$fp</span><span class="p">);</span> <span class="cm">/* resource(2) of type (stream) */</span>
</pre></div>
</div>
<p>Internally, a resource is bound to the <code class="docutils literal notranslate"><span class="pre">zend_resource</span></code> structure type:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">_zend_resource</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">zend_refcounted_h</span><span class="w"> </span><span class="n">gc</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w">               </span><span class="n">handle</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w">               </span><span class="n">type</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="w">             </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We find the traditional <code class="docutils literal notranslate"><span class="pre">zend_refcounted_h</span></code> header, meaning that resources are reference countable.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">handle</span></code> is an integer that is used internally by the engine to locate the resource into an internal resource
table. It is used as the key for such a table.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">type</span></code> is used to regroup resources of the same type together. This is about the way resources get destroyed and
how they are fetched back from their handle.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">ptr</span></code> field in <code class="docutils literal notranslate"><span class="pre">zend_resource</span></code> is your abstract data. Remember resources are about storing an abstract
data that cannot fit in any data type PHP can represent natively (but objects could, like we said earlier).</p>
</section>
<section id="resource-types-and-resource-destruction">
<h2>Resource types and resource destruction<a class="headerlink" href="#resource-types-and-resource-destruction" title="Link to this heading">¶</a></h2>
<p>Resources must register a destructor. When users use resources in PHP userland, they usually don’t bother cleaning
those when they don’t make use of them anymore. For example, it is not uncommon to see an <code class="docutils literal notranslate"><span class="pre">fopen()</span></code> call, and not see
the matching <code class="docutils literal notranslate"><span class="pre">fclose()</span></code> call. Using the C language, this would be at best a bad idea, at most a disaster. But using a
high level language like PHP, you ease things.</p>
<p>You, as an internal developer, must be prepared to the fact that the user would create a lot of resources you’ll allow
him to use, without properly cleaning them and releasing memory/OS resource. You hence must register a destructor that
will be called anytime the engine is about to destroy a resource of that type.</p>
<p>Destructors are grouped by types, so are resources themselves. You won’t apply the destructor for a resource of type
‘database’ than for a resource of type ‘file’.</p>
<p>There also exists two kinds of resources, here again differentiated about their lifetime.</p>
<ul class="simple">
<li><p>Classical resources, the most used ones, do not persist across several requests, their destructor is called at
request shutdown.</p></li>
<li><p>Persistent resources will persist across several requests and will only get destroyed when the PHP process dies.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You may be interested by <a class="reference internal" href="../extensions_design/php_lifecycle.html"><span class="doc">the PHP lifecycle</span></a> chapter that shows you
the different steps occurring in PHP’s process life. Also, the
<a class="reference internal" href="../memory_management/zend_memory_manager.html"><span class="doc">Zend Memory Manager chapter</span></a> may help in understanding
concepts of persistent and request-bound memory allocations.</p>
</div>
</section>
<section id="playing-with-resources">
<h2>Playing with resources<a class="headerlink" href="#playing-with-resources" title="Link to this heading">¶</a></h2>
<p>The resources related API can be found in
<a class="reference external" href="https://github.com/php/php-src/blob/3704947696fe0ee93e025fa85621d297ac7a1e4d/Zend/zend_list.c">zend/zend_list.c</a>.
You may find some inconsistencies into it, like talking about “lists” for “resources”.</p>
<section id="creating-resources">
<h3>Creating resources<a class="headerlink" href="#creating-resources" title="Link to this heading">¶</a></h3>
<p>To create a resource, one must first register a destructor for it and associate it to a resource type name using
<code class="docutils literal notranslate"><span class="pre">zend_register_list_destructors_ex()</span></code>. That call will return an integer that represents the type of resource you
register. You must remember that integer because you will need it later-on to fetch back your resource from the user.</p>
<p>After that, you can register a new resource using <code class="docutils literal notranslate"><span class="pre">zend_register_resource()</span></code>. That one will return you a
<code class="docutils literal notranslate"><span class="pre">zend_resource</span></code>. Let’s see together a simple use-case example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">res_num</span><span class="p">;</span>
<span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fp</span><span class="p">;</span>
<span class="n">zend_resource</span><span class="w"> </span><span class="o">*</span><span class="n">my_res</span><span class="p">;</span>
<span class="n">zval</span><span class="w"> </span><span class="n">my_val</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_res_dtor</span><span class="p">(</span><span class="n">zend_resource</span><span class="w"> </span><span class="o">*</span><span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">((</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* module_number should be your PHP extension number here */</span>
<span class="n">res_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zend_register_list_destructors_ex</span><span class="p">(</span><span class="n">my_res_dtor</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;my_res&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">module_number</span><span class="p">);</span>
<span class="n">fp</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;/proc/cpuinfo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="n">my_res</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">zend_register_resource</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="n">res_num</span><span class="p">);</span>

<span class="n">ZVAL_RES</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_val</span><span class="p">,</span><span class="w"> </span><span class="n">my_res</span><span class="p">);</span>
</pre></div>
</div>
<p>What we do in the code above, is that we open a file using libc’s <code class="docutils literal notranslate"><span class="pre">fopen()</span></code>, and store the returned pointer into a
resource. Before that, we registered a destructor which when called will use libc’s <code class="docutils literal notranslate"><span class="pre">fclose()</span></code> on the pointer. Then,
we register the resource against the engine, and we pass the resource into a <code class="docutils literal notranslate"><span class="pre">zval</span></code> container that could get returned
to userland.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zvals chapter can be found <a class="reference internal" href="../zvals.html#zvals"><span class="std std-ref">here</span></a>.</p>
</div>
<p>What must be remembered is resource type. Here, we register a resource of type <em>“my_res”</em>. This is the type name. The
engine does not really care about type name, but type identifier, the integer returned by
<code class="docutils literal notranslate"><span class="pre">zend_register_list_destructors_ex()</span></code>. You should remember it somewhere, like we do in the <code class="docutils literal notranslate"><span class="pre">res_num</span></code> variable.</p>
</section>
<section id="fetching-back-resources">
<h3>Fetching back resources<a class="headerlink" href="#fetching-back-resources" title="Link to this heading">¶</a></h3>
<p>Now that we registered a resource and put it in a <code class="docutils literal notranslate"><span class="pre">zval</span></code> for an example, we should learn how to fetch back that
resource from the userland. Remember, the resource is stored into the <code class="docutils literal notranslate"><span class="pre">zval</span></code>. Into the resource is stored the resource
type number (on the <code class="docutils literal notranslate"><span class="pre">type</span></code> field). Thus, to be given back our resource from the user, we must extract the
<code class="docutils literal notranslate"><span class="pre">zend_resource</span></code> from the <code class="docutils literal notranslate"><span class="pre">zval</span></code>, and call <code class="docutils literal notranslate"><span class="pre">zend_fetch_resource()</span></code> to get back our <code class="docutils literal notranslate"><span class="pre">FILE</span> <span class="pre">*</span></code> pointer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* ... later on ... */</span>

<span class="n">zval</span><span class="w"> </span><span class="o">*</span><span class="n">user_zval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* fetch zval from userland, assume type IS_RESOURCE */</span>

<span class="n">ZEND_ASSERT</span><span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">user_zval</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IS_RESOURCE</span><span class="p">);</span><span class="w"> </span><span class="cm">/* just a check to be sure */</span>

<span class="n">fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">zend_fetch_resource</span><span class="p">(</span><span class="n">Z_RESVAL_P</span><span class="p">(</span><span class="n">user_zval</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;my_res&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">res_num</span><span class="p">);</span>
</pre></div>
</div>
<p>Like we said : get back a zval from the user (of type <code class="docutils literal notranslate"><span class="pre">IS_RESOURCE</span></code>), and fetch the resource pointer back from it by
calling <code class="docutils literal notranslate"><span class="pre">zend_fetch_resource()</span></code>.</p>
<p>That function will check if the type of the resource is of the type you pass as third parameter (<code class="docutils literal notranslate"><span class="pre">res_num</span></code> here).
If yes, it extracts back the <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> resource pointer you need and we are done. If not, then it throws a warning like
<em>“supplied resource is not a valid {type name} resource”</em>.
This could happen if for example you expect a resource of type “my_res”, and you are given a zval with a resource of
type “gzip”, like one returned by <code class="docutils literal notranslate"><span class="pre">gzopen()</span></code> PHP function.</p>
<p>Resource types are just a way for the engine to mix different kind of resources (of type “file”, “gzip” or even “mysql
connection”) into the same resource table. Resource types have names, so that those can be used in error messages or in
debug statement (like a <code class="docutils literal notranslate"><span class="pre">var_dump($my_resource)</span></code>), and they also are represented as an integer used internally to
fetch back the resource pointer from it, and to register a destructor with the resource type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Like you can see, if we would have used objects, those represent types by themselves, and there wouldn’t have
to happen that step of fetching back a resource from its identifier verifying its type. Objects are
self-describing types. But resources are still a valid data type for the current PHP version.</p>
</div>
</section>
</section>
<section id="reference-counting-resources">
<h2>Reference counting resources<a class="headerlink" href="#reference-counting-resources" title="Link to this heading">¶</a></h2>
<p>Like many other types, <code class="docutils literal notranslate"><span class="pre">zend_resource</span></code> is reference counted. We can see its <code class="docutils literal notranslate"><span class="pre">zend_refcounted_h</span></code> header. Here is the
API to play with reference counting, if you need it (you shouldn’t really need it on an average):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">zend_list_delete(zend_resource</span> <span class="pre">*res)</span></code> decrements refcount and destroys resource if drops to zero</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zend_list_free(zend_resource</span> <span class="pre">*res)</span></code> checks if refcount is zero, and destroys the resource if true.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zend_list_close(zend_resource</span> <span class="pre">*res)</span></code> calls the resource destructor whatever the conditions</p></li>
</ul>
</section>
<section id="persistent-resources">
<h2>Persistent resources<a class="headerlink" href="#persistent-resources" title="Link to this heading">¶</a></h2>
<p>Persistent resources don’t get destroyed at the end of the request. The classical use-case for that are persistent
database connections. Those are connections that are recycled from request to request (with all the bullshit that will
bring).</p>
<p>Traditionally, you should not be using persistent resources, as one request will be different from the other. Reusing
the same resource should really be thoughtful before going this way.</p>
<p>To register a persistent resource, use a persistent destructor instead of a classical one. This is done in the call
to <code class="docutils literal notranslate"><span class="pre">zend_register_list_destructors_ex()</span></code>, which API is like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zend_register_list_destructors_ex</span><span class="p">(</span><span class="n">rsrc_dtor_func_t</span><span class="w"> </span><span class="n">destructor</span><span class="p">,</span><span class="w"> </span><span class="n">rsrc_dtor_func_t</span><span class="w"> </span><span class="n">persistent_destructor</span><span class="p">,</span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">type_name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">module_number</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="strings/printing_functions.html">PHP’s custom printf functions</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="hashtables.html">HashTables: zend_array</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>